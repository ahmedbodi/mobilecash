//
//  BRPeerManager.m
//  BreadWallet
//
//  Created by Aaron Voisine on 10/6/13.
//  Copyright (c) 2013 Aaron Voisine <voisine@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#import "BRPeerManager.h"
#import "BRPeer.h"
#import "BRPeerEntity.h"
#import "BRBloomFilter.h"
#import "BRKeySequence.h"
#import "BRTransaction.h"
#import "BRTransactionEntity.h"
#import "BRMerkleBlock.h"
#import "BRMerkleBlockEntity.h"
#import "BRWalletManager.h"
#import "NSString+Bitcoin.h"
#import "NSData+Bitcoin.h"
#import "NSManagedObject+Sugar.h"
#import "BREventManager.h"
#import "breadwallet-Swift.h"
#import <netdb.h>

#if ! PEER_LOGGING
#define NSLog(...)
#endif

#define FIXED_PEERS          @"FixedPeers"
#define PROTOCOL_TIMEOUT     20.0
#define MAX_CONNECT_FAILURES 20 // notify user of network problems after this many connect failures in a row
#define CHECKPOINT_COUNT     (sizeof(checkpoint_array)/sizeof(*checkpoint_array))
#define GENESIS_BLOCK_HASH   (*(UInt256 *)@(checkpoint_array[0].hash).hexToData.reverse.bytes)
#define SYNC_STARTHEIGHT_KEY @"SYNC_STARTHEIGHT"

#if BITCOIN_TESTNET

static const struct { uint32_t height; const char *hash; uint32_t timestamp; uint32_t target; } checkpoint_array[] = {
};

static const char *dns_seeds[] = {
};

#else // main net

// blockchain checkpoints - these are also used as starting points for partial chain downloads, so they need to be at
// difficulty transition boundaries in order to verify the block difficulty at the immediately following transition
static const struct { uint32_t height; const char *hash; uint32_t timestamp; uint32_t target; } checkpoint_array[] = {
    { 0, "218abb16cbe8df616cec3624ececb76b30a4ea3926cb8b4479cba1d07a45edc8", 1441144114, 0x01000000u },
    { 2016, "25eae674ca19b4d5e7f75873cc07d493225279da5cd67fffca5d863ff1bc7c50", 1443048528, 0x01000000u },
    { 4032, "5921c996be9c1b3e304d86e2987d08fddd76a0b32c85ed69cd8fb7a190182a99", 1443051383, 0x01000000u },
    { 6048, "063f821af1499a3718a337447dace2ae8a3f54c64896ca1afeb892e49783ec0a", 1443058471, 0x01000000u },
    { 8064, "d1cfef49ca696685fef2fffc2ac220d4e83ba8ec15dd2274068cbb1ffc3dd301", 1443065041, 0x01000000u },
    { 10080, "7c552bc2b9021e93680e6ed600c1b35d82a3b768414d0cefd411bb4ba7f14a25", 1443071344, 0x01000000u },
    { 12096, "85f644c2e4d3474943c5497a9f067adbc1f04a1883c81164e8f28ff89d8271a8", 1443088005, 0x01000000u },
    { 14112, "38be5fe7d0cfef0c61bab4f17c26d04e880a430ac4a7210557590de103873022", 1443156610, 0x01000000u },
    { 16128, "387db9a21adee486c72718f339509a90b7261c4d3bf0f01815169815a5a70a8b", 1443217153, 0x01000000u },
    { 18144, "95489c838779111a0812f7784147454f20c0e06b0f82e78d973ca4f6a357a19d", 1443292717, 0x01010000u },
    { 20160, "2c3f7d82d7f58eeeb6604912de38bbdbdf21b3c2dd10596143bed9448fb5976d", 1443346814, 0x01030000u },
    { 22176, "b7402914f64b8e3431b6c102321f6202b86f12f068f0dbe27b30ab96edc0f256", 1443402383, 0x01060000u },
    { 24192, "92c7074097716eb76ff9c4cb4ca45b1a00ac47b2ab6eeca826b9cc61c1899590", 1443597762, 0x01040000u },
    { 26208, "519d396fede0d1b2f001fd97c8f8c2d95fe31d08227423fec550a68132b7cbce", 1443677048, 0x01060000u },
    { 28224, "b53511ffe1ca83f87afa2d07184ec1c37f22849a9360352dab3020db996aadbc", 1443736182, 0x010d0000u },
    { 30240, "b022eeaf14727a6b56c742d0dcbdafd5fb2f3d7893bde740f3758d137155dba3", 1443822158, 0x01120000u },
    { 32256, "3814fb806595643d5d60ee3c234272215a34056541b9893fa34b7adbfdc830b0", 1443975644, 0x010e0000u },
    { 34272, "7119a5e9fa627ed4ec8e8349966e9d905ab13dd3213373e68ad994b749e6867a", 1444087966, 0x010f0000u },
    { 36288, "7e011a2426a61037b8f3a1659d9017eba709e6bf617759d558d72684fa97619d", 1444199723, 0x01110000u },
    { 38304, "ea7757a8200122aecacf40006f9ec59d084b1af1942d079c6c21ad97d97ef821", 1444300668, 0x01140000u },
    { 40320, "de9170828d323d7f58b479719e340270e729ad416dda8d683ed6415c069c7b15", 1444411765, 0x01160000u },
    { 42336, "39e8a7316f36f8613a8c115c49ff38501f977b8c650746e04f9c15e57e13800c", 1444535768, 0x01160000u },
    { 44352, "11bbbca40ac8db05f7e510d0ce6f3f931092110b055b9d137fb912a4d272685b", 1444631305, 0x011c0000u },
    { 46368, "75c2cf1a09793bf297c6a531189527c9da2c4169def83724b3517bcd02defe83", 1444712205, 0x012a0000u },
    { 48384, "209557673f74889852eadd5f6f959ec54e7d13c82bcdd8a50de3be5248fdf7e7", 1444901243, 0x011a0000u },
    { 50400, "62524ac1531be467b1b675e673b87c2c648f6adb7092253958f59af92860a987", 1445020740, 0x011b0000u },
    { 52416, "6c13cb4ccbf7aee8b8c43390fd50d293cbdc817c206a9516bbde70e7883f6594", 1445144019, 0x011a0000u },
    { 54432, "00cd78f60276aaa5061c9a2d5be5eb8af72427c095bfe7fa175974f9ef1fb49c", 1445268907, 0x01190000u },
    { 56448, "31bd769643e1b17bc14cd9051dfc3456a0bc29dec296dea8a470eab7b27e8aab", 1445369417, 0x011f0000u },
    { 58464, "383d8df83c2b56adc67866f601447259a2fa556922fb38d89d9782622ed4d60f", 1445489052, 0x011f0000u },
    { 60480, "ee417f69a9ed4beb9c9d876aa2932493100c0bf8602a94bd3b1e384270c5ea3d", 1445576007, 0x012b0000u },
    { 62496, "53097461278939166bf1b25465858f39cec0ac5265c3342d4fe8ab09ba443616", 1445673774, 0x01360000u },
    { 64512, "105efbd07a268e3d2f16ca65c1e4c0e1d1f916f13ceeaf3e1df901d6d60b7a9e", 1445808809, 0x01300000u },
    { 66528, "730f4f4830643a1486ab389acb53196ed4ec17b16aa1b887fc691c6ca6998098", 1445920417, 0x01350000u },
    { 68544, "3aba1409a86306367e8a0446c7077a710522369a62c57fc1f34125b645972403", 1446088821, 0x01250000u },
    { 70560, "16fe92231afec7f1484514b24498b74c0a233262a32f48db0985c4a1af93015f", 1446179128, 0x01330000u },
    { 72576, "50e66aeeccba35b157a3c06a0a6882adf69ee818ed91a16ea1ad1e558f7e61b4", 1446329095, 0x01290000u },
    { 74592, "bb6d51f5a39d814167f4f1ab16b183614b034495ec1570bf15dafe37b4276230", 1446450861, 0x01290000u },
    { 76608, "31d94a486c7892bd292d3fb1403392d06bddc2e54ae093812dabe87e9d2b1be7", 1446668729, 0x01160000u },
    { 78624, "658b40c84d5dcd01ae957b198604604f36fc349e53b7727c3e85976b11dcb488", 1446753814, 0x01200000u },
    { 80640, "eb25da635036ec046c26e603613d0f54e307fc9f48d868a9b0520c833e7eb580", 1446850319, 0x01280000u },
    { 82656, "ea339db61cdd517bacc90138dbd01399a08c48e412b8cff0b63ad076b4f3eb92", 1446970297, 0x01290000u },
    { 84672, "d165747b5912b6012ca8537213f52b47a7d1f0c14b603093688ca551d05ae608", 1447109972, 0x01230000u },
    { 86688, "d04e7822a00b5508cfea88eb217e94a75553d5c753addd88c6c1fd8308c02d06", 1447219336, 0x01270000u },
    { 88704, "722712dd814166afb8d1f4f9e3bbdc1d9466434957cb67bbb29a3e5c4dacdd69", 1447323016, 0x012e0000u },
    { 90720, "83a8a0b24c09206b8b200e8fcacdce5e1da1ed3b679c405bae55399605ecfe29", 1447430837, 0x01330000u },
    { 92736, "112066c471247c5514088e46895bcbf2f894f10777ed40ad93efdd745ba2ea37", 1447577812, 0x012b0000u },
    { 94752, "8aca92f453e57b1a624afa1f9f2c937d2be35a7e4dce83a8a9990861fe093adb", 1447715629, 0x01250000u },
    { 96768, "93e30c27018127c217990160e73d51c6513ad86a5ba480dd57cf09c84eb896b7", 1447881147, 0x011b0000u },
    { 98784, "c67c46c2964ff6a5d7650a8bfe38c82c69cd1409c40ae0ff4daaca87d4f46034", 1447992735, 0x011d0000u },
    { 100800, "575c52f938fda81ece7aeedb016e218c67d9beafc9cc467bf4a9b9c660abc5f6", 1448110080, 0x011e0000u },
    { 102816, "ef41d0e3e055ba3bfb77a6fa0d241354850a265b8830adbf466242ad4829d3c6", 1448261551, 0x01180000u },
    { 104832, "4ee1643e1070d3cc8d4cf08c364424943c64c1d73655ca04edf13b1465a7cd05", 1448357451, 0x011f0000u },
    { 106848, "1899262357662d771fe28ec51a63b4a156ba35603ab1709edca2b60f63cbf444", 1448489508, 0x011c0000u },
    { 108864, "4fbaa8717d323bc1808480e0983bd87f9de6f2f180c4a7b6ed2f690911ecdb10", 1448593839, 0x01210000u },
    { 110880, "a23a9a6177831412258e5c6b37014cdab96ce46f981f3880bf0bc99f9099f132", 1448738511, 0x011b0000u },
    { 112896, "6fad160edc17b41ba84799b3e04460a6a2843b0659e8ac552e2f33d1cd76bc55", 1448835160, 0x01220000u },
    { 114912, "b11a75d6d45352ad20382b0778f409b91f9ebce842233a8cbfa00b5d75316ac5", 1448942073, 0x01270000u },
    { 116928, "7414d554df68c1cedb97783796cf0b13be09d4630589ba6b96e0ec1ab7f4bc41", 1449057161, 0x01280000u },
    { 118944, "58d565421beecf98a885190eda68f55d44027f7f7baf6acdce6145dd9d11c339", 1449156868, 0x01320000u },
    { 120960, "9681f67ad319480a50e0b937d0e4c1add4be4843dc8a49366568238e36a4bf80", 1449279298, 0x01320000u },
    { 122976, "6e753a5dbf6917bef91e70526058d6b07d3d6942cae0a4d6789714b16f1df02f", 1449448943, 0x01230000u },
    { 124992, "d2fcedc88b1050da3f0c3feb84dc221d7caca268d423f278e12c8f33eace952b", 1449570246, 0x01230000u },
    { 127008, "57aaf5b79989e05e18676ac77542c523a5ccf0b8299400afab98396f96e122e1", 1449729109, 0x011b0000u },
    { 129024, "a8de64b38d823f4c7215d36bd742d087a716fa12a4ff718f0995212f63251b1b", 1449885341, 0x01140000u },
    { 131040, "d87fe92321022822d232aa005b4f3963c4f9eb7fee8d77de07c19fd4666536e8", 1449975866, 0x011b0000u },
    { 133056, "4c40c36ed08667222fab1e88cff5d5066a0dd5f23136b28b99a2efcc5ef7fe03", 1450091516, 0x011e0000u },
    { 135072, "69c6945a5b53d088a29b707ae035767e765e564e9e2ac1b3976ada099167e586", 1450225325, 0x011a0000u },
    { 137088, "180338790e530d80ea4cc34d8015a09ec05bd04855f646319c40ca67316d55a9", 1450392806, 0x01130000u },
    { 139104, "2bf7e5965e1077b1d248c8fed21516710159117622c7ce3552e9798d179b1c83", 1450497861, 0x01160000u },
    { 141120, "2ebbdc3fd0265106e5f6f85a6dff4a7ee62dccf26a96aec1ea60a7abbc303422", 1450684531, 0x010e0000u },
    { 143136, "05b08e5ccf36882dcf657ac4f1f8f5010b59bc67a562b46612eb70bc7741d518", 1450799979, 0x010f0000u },
    { 145152, "1cdb2f53f5a560e0088528449e9d112bf338c20ea81e684e9f2858b8fa5da863", 1450902536, 0x01110000u },
    { 147168, "7b1c2096700391a850af635b609787db6a72c1caf5a035159e9e497a57e6826d", 1451015163, 0x01130000u },
    { 149184, "3f4ee0ac8e3d0d54ee89e1aaeaf79ed10f2e6a3ebb9671abb5b5fe8d7af56d64", 1451131614, 0x01130000u },
    { 151200, "5da7f6f1dd0f770fc4aa873685cb7d25d149f676744995eddc950233c988bbc7", 1451227920, 0x01180000u },
    { 153216, "d51441948d9186036257da302a7c2fff5f00980ac72e37725569e6cf47ef82fe", 1451350068, 0x01180000u },
    { 155232, "cfdc66d103af69cc525e641dad86b2fc3a9f58951e7640af3ee501ced6dc7b50", 1451504272, 0x01130000u },
    { 157248, "a14ead60b9cd91b3725bf30cc01ce8e2e185101c1841c456a874b96e97eabdde", 1451601814, 0x01180000u },
    { 159264, "4f81519be8f460360e1c786dfd9744b14e3eb9bcf8d9a3dfeed1dd83dc360427", 1451750373, 0x01130000u },
    { 161280, "bafb3928fa92a4edf1889175f0ed10123a8e6150da5d3b4ba189b1e3d0313c56", 1451921850, 0x010e0000u },
    { 163296, "12085cc0c85d18d0cd36968ea564c8ab5c00cc860a9c5b85c1c28598ace384f3", 1452002996, 0x01140000u },
    { 165312, "0348bf534c5bc18950720ff9fbf05ade6e8ce416f6a4e17320bd705222b0a7be", 1452127720, 0x01130000u },
    { 167328, "4e2b14bb697b28402f3786ed5e7b481200ed7dbb567fce68afd9334010e70155", 1452278154, 0x01100000u },
    { 169344, "d93025ca378a1686c05f3a1288107a9a422990d2659e35b17885921ad1008015", 1452389874, 0x01110000u },
    { 171360, "ffada6f02a5481439cbe421bf67e56682183abab6a2c5dfb7b2560dadedd4a25", 1452540698, 0x010d0000u },
    { 173376, "4158097961095b44f8a0934b5558fb3e70a75978ea37db46202a2cb435ff687d", 1452643271, 0x01100000u },
    { 175392, "5b630126386fde1f557515dbe032c5ec3ee5f47e4c0aa3475d5cacfeced3b7ea", 1452763621, 0x01100000u },
    { 177408, "176e26b30deba101bff141e43647cbb1f7811b468ad123b39bd96194175d66c6", 1452889811, 0x010f0000u },
    { 179424, "72a0f3a512e79a032843acedef4568599fdb826e9c680e29dda9073cacfb6333", 1452979997, 0x01140000u },
    { 181440, "ed2d60106a2cbb2733651cd80f69101481af5461dd4247af0e03b0069395e12f", 1453134636, 0x01100000u },
    { 183456, "eeaf6af95c3f8c50c6b42ae74b99a707d33d64e59f3fc745ee2b8cea1ecee4e5", 1453256843, 0x01100000u },
    { 185472, "8062bd2de78639e4a630a25e2ebe72e6fa975900f1bbc1c27a764117e5092d06", 1453368814, 0x01110000u },
    { 187488, "5ecaf41fd93b35a57f50bd60ff44aa2b365e5630c7f7f76672d46bafc8d09f09", 1453505173, 0x010f0000u },
    { 189504, "3aa1e72237111c415cc72ba2e7ccb6d1a4ce2204183b95d6a6682c97b9aa8602", 1453636640, 0x010e0000u },
    { 191520, "dbfbbc959d41fede44f80380ecab3828473bd522e9f2b5716e93bda7c21e43a7", 1453742884, 0x01100000u },
    { 193536, "43ddb2d81776644a969adc1de355e18235ec9edc01bb43b21acd94ba45ad1c49", 1453851231, 0x01120000u },
    { 195552, "9764210a1ff625757b37ec9791c84d970285bf3d483b415492b18ccea27b30f5", 1453926869, 0x011c0000u },
    { 197568, "545ef91ad326ad4d20bab671e6bc141676e92b5134764d1271d43fa085b5f5f3", 1454036519, 0x01200000u },
    { 199584, "eae42d179a1be44c7e988a98ad59bd42e54bc6a74d9a0b8a8b7a931ae38f2989", 1454218767, 0x01150000u },
    { 201600, "4bbc76be52631e76e27f96f361391aa6ddc5d1745e389a8cca002c81b2e3bdb2", 1454415680, 0x010d0000u },
    { 203616, "08edbacc709c3632212d3799f03820d95e16994a8b780841125c507503a1c603", 1454517302, 0x010f0000u },
    { 205632, "2ff9f89cd9b7b5e996b40cfdfd03d0f1f835bf8bc00d3b81def751a5f0945353", 1454665757, 0x010c0000u },
    { 207648, "dc7d869f0c6ebe844cb80711d59d3dff1c854121c2ba0bd6a72398489ce976a1", 1454724515, 0x011d0000u },
    { 209664, "74d7b1732964fd49aa8d1222e0fbb44107dd8c8736c224bf05739bdab899a755", 1454849302, 0x011c0000u },
    { 211680, "536c4d0b75b0409f8715fc7bfd0260d32e616c562cfb56dbf443f17136e28888", 1455032844, 0x01120000u },
    { 213696, "f21db289e9206f5915c143fc5bc8aeed6959c6932c07e3d58c83c0587cb3fbdc", 1455163938, 0x01120000u },
    { 215712, "fe1a58d0c84490a64d1d18a81ccad86aa5182085661621102cbeb6e5ed081a85", 1455387825, 0x01090000u },
    { 217728, "22aa415995496e6146b996540779a67ff8a1c52a26f6d50cf10e121553196cc6", 1455460326, 0x010f0000u },
    { 219744, "cb34a5624c2f798177644ec680bfea136ac6987bf7055f380886e9da3f4d69bb", 1455748878, 0x01060000u },
    { 221760, "673b03fbdffdda850d2fda099124d61960c262e6ce5377456e1b258889d52a29", 1455786193, 0x01160000u },
    { 223776, "4d67921cb1d852bd3a05b33b31e554511b8dbd8b10352f3d9f6bebfb83b57ab8", 1456354903, 0x01050000u },
    { 225792, "ca86955bc9333b1170e8badbfa4083e89629ba25709c634814374036e285104e", 1456610259, 0x01020000u },
    { 227808, "b8bc6da280a2ec09a6a4335e289c714f0224e66152a708954e25dc060c3bc237", 1456715871, 0x01020000u },
    { 229824, "b4ec96a70e0153841b84bd440597cafd034e2bef43ed73ab6d675d78bdd4a70d", 1456853279, 0x01020000u },
    { 231840, "f3c1947e43244f2d3bcc19a93a670889169f63782d5d2c89082170387f758ca7", 1456954981, 0x01020000u },
    { 233856, "28139f2cf9a7c5b89274c80d3bb2483d8784006813a768d96f3609f25009c099", 1457018772, 0x01060000u },
    { 235872, "eb2fcbe289cb609ce7f61e10d7db91e7653465dcf0494f364e4aeeb822eb7480", 1457185789, 0x01040000u },
    { 237888, "f82d93160c9794baaf73950b7cdc055d780c6dd7f799707b402524475e288dc3", 1457354860, 0x01030000u },
    { 239904, "488e2fd4d50764c3d1288ec6230fac7ef4547ca2536ce7c64553b6f1bf37fa37", 1457424730, 0x01050000u },
    { 241920, "3552081b8b171eac726f2eb7124005c2b4eebe861266dcc3bdad3ee9458b280c", 1457564448, 0x01040000u },
    { 243936, "fdcf5e1d7aa41623c5acbccf2ba3b78215a4d1f9c0f6501d769587916988020d", 1457653499, 0x01060000u },
    { 245952, "e00c902c0d88209788166527627655dd716ae9d19ecb34823042e97f1707724d", 1457763753, 0x01070000u },
    { 247968, "f1907c28de2c6dc64792c0be4e0e319b057acd3b41df1fd3d323df58a073443b", 1457846223, 0x01090000u },
    { 249984, "54ad9888c55da0a61305a79d3b226e7c080a9c89d06a2bae03aea1ec9d0268c0", 1457918857, 0x01100000u },
    { 252000, "09bda63dcc9e2c5d8f5885c938e5ad2874fad8be7b3661137b17cab374b5a9d8", 1458029749, 0x01120000u },
    { 254016, "bcbc2c332fa824e100cbf1e7420a58d2851cbcfe5546e80deb54074eca83a95e", 1458124606, 0x01170000u },
    { 256032, "df5edb1f4a74eeb3d96787c03de8b1407e760ae81c61f00101f631bf573f2bcd", 1458235756, 0x01190000u },
    { 258048, "1e400fa049446580f52131001991ac8a034f8d2281a896084fdde64ba51e2c29", 1458377312, 0x01150000u },
    { 260064, "44152d7fddb4a7157338ffb9b201166d5eae9ef48a2347036e90bfcc7fb58e09", 1458570127, 0x010e0000u },
    { 262080, "7a755df0ecbab6e9968a3df092602b4c94dbe6fe16db558b689fbfa8f00a4a1d", 1458746845, 0x01090000u },
    { 264096, "86abb9291133c2087e78749f13412b79089c07758c50ce4eb8b712df9f959a46", 1458889522, 0x01070000u },
    { 266112, "bd3796b2d8a8d40cc7ccf10f7b5490891fbcda903e3473558631bf90bcce4d68", 1459039318, 0x01060000u },
    { 268128, "f2e52aca581bff248619fedc7869e247851e271326e40886fd37148f5ae24f3f", 1459148955, 0x01070000u },
    { 270144, "272118cf05908ace6122cf195a91fb404fcc033a26777ac6883efb6571de4607", 1459215937, 0x010c0000u },
    { 272160, "789424d9606964e133eb8e5e221600445f05143d39592c6c7f066a167952e2c1", 1459333643, 0x010e0000u },
    { 274176, "be57aea75da400c692b6d807c94476364ae369fd8658d0877c750d615e8fd165", 1459490250, 0x010a0000u },
    { 276192, "3e2abfd990a6b653baa8d404e39258f865b8031caecc6c3587f2968738bf6452", 1459665971, 0x01070000u },
    { 278208, "2728367464277e21e334f2744b448532a78b3095f3a3d6a97e9ddc791f7caba8", 1459799791, 0x01060000u },
    { 280224, "c7b2e9526c38def1c9c39f1b2cb9d0ff6c58a9ee302ff137bd5c5d5476dba7cf", 1459932421, 0x01050000u },
    { 282240, "eb866a97985595d1dfcc4dfb465d996fd4b7511a06fbd24ca576b3674f8a6667", 1460068578, 0x01050000u },
    { 284256, "b4f5a5f0765f9511a29c7d0eb1262d50547d5c7351916b628bf73e55952bd4c1", 1460172577, 0x01050000u },
    { 286272, "21de55d9ff87396f8fa7ecc0d389d53d1a474920a331d0cd22f249e99cd24bc3", 1460304825, 0x01050000u },
    { 288288, "1747a1cfea3c1e9af26116e33f03adf310e98be250099acc68927480f6700b17", 1460421777, 0x01050000u },
    { 290304, "3c4fe94e112efefd26e73cfcee715137d1723d9239b1f5068663c728c3d243b2", 1460523157, 0x01060000u },
    { 292320, "7d38a557555737be984ea5a2a5f05f51f8021ee46125c60086cf7817b7314d7c", 1460611966, 0x010a0000u },
    { 294336, "9a1b7d791186a87eafcbe96d73e69b95457e6ab152ec8d8bd3d8bd7828373f1b", 1460741319, 0x01080000u },
    { 296352, "8b0294d078427f5f4a792fb90522867c6e09c6fa8e943357d9713fae78eb01d2", 1460841191, 0x010b0000u },
    { 298368, "22c8c536f78e3a0a7e3556c67c3d7a17892f659acb35b11e8aaa29058fa73cf3", 1461052551, 0x01060000u },
    { 300384, "d982204bc261edb2663eac92a8e88e7efb1b72927ccbd17ee1aa0b2661f355cc", 1461138302, 0x01090000u },
    { 302400, "ea6e5f38868ca67b99587bba5ea43db003b6cde5abd85630e83da026d9d6c196", 1461226491, 0x010c0000u },
    { 304416, "d070b4f6ec3e6953a3996569306f17a7d160afb66b8736f69144dbb6d2691855", 1461330719, 0x010f0000u },
    { 306432, "0bb09645fc214f620ca1b5ae2c5a614c8d9626ffba974e98a15d44a2886c6bf2", 1461413340, 0x01190000u },
    { 308448, "8428b7729bcfaf66ffde5c194b8a84a8b8e279255fd63513186f2c0087a59a37", 1461716099, 0x01090000u },
    { 310464, "29372d98a5925988f0a6f7666b3892e31120a05c9fa93cf88cb52d0637abe02b", 1461806419, 0x010c0000u },
    { 312480, "f69c305e4e1cee64bd2193935681b4b49d27e27b32f6e714f0703e74be0b5f33", 1462002283, 0x01080000u },
    { 314496, "04f803302e3ba9cb3985e58e774752eb780ed89cad1a8a0cbd809b5abed2d810", 1462140766, 0x01070000u },
    { 316512, "1ab76e623b148380adedf6c2a0f553a70e4ac2f2cf8e04b29dfa091a18744973", 1462252308, 0x01070000u },
    { 318528, "87a128697e8876414d9ce4df88f4674aad93c4ac52d485b9f3a4524d5d503103", 1462402620, 0x01060000u },
    { 320544, "2c46899fbbf223b611394c8f478bd642bee83e4e0e410f9264ce618911704bff", 1462542764, 0x01050000u },
    { 322560, "e7b2d74f251752477e91f62d015e792299e1719830c3afcc502824dd1f063141", 1462638391, 0x01060000u },
    { 324576, "e664cedea089fa6e97061e47802477f5aabf8c1889f3cef474ca00b27659f65e", 1462768738, 0x01060000u },
    { 326592, "3ae97cfce0888a9041efeecbc44ff8ad86d9593965fed4d2c8ac1788adf2ae40", 1462877997, 0x01070000u },
    { 328608, "903ad76be549a8d44be524fd93049f7278050b8c3142e35d625b7a4edcf657d8", 1462997682, 0x01060000u },
    { 330624, "f39a45ad118f1f6eb6a8032a7f1e618e06060d0ee491ff9643bf29f9b41a96c9", 1463110505, 0x01070000u },
    { 332640, "08de3320ce4d525c1082c6da0e11b53bc62129b84b8424df98875eec4376526f", 1463252006, 0x01060000u },
    { 334656, "e7008bc6d95b3fea5115ac3bdaad19a147afec9226e35a0271874a212a800480", 1463398574, 0x01050000u },
    { 336672, "5e33f6f5fdb9a93c9e601ba450530f2007f5b8c69487cc3aeb3aee9ba3806b94", 1463516342, 0x01050000u },
    { 338688, "76f32cfbc4306e32fda2120a0ce10b2ac58ac77666c3eab9fa627349677449f1", 1463630081, 0x01060000u },
    { 340704, "3da35e4e259918f323a6f0ea139082eb03ce5c9813875da8ca68b6f9c3211ea9", 1463758933, 0x01050000u },
    { 342720, "f2bb282dbcf224b203efd3172728271ba2c3d6b2c3c8941f167d2e9b141fae57", 1463901668, 0x01040000u },
    { 344736, "9bb6b685ec66a5c46e72ce21cc6e224ea61c6a7be6cb789bbeae8b370d642318", 1464015066, 0x01040000u },
    { 346752, "89c845cb10ebc4bead2a575e2e7c606db30f064221cb8d82b4b39ea7e8201c84", 1464109515, 0x01060000u },
    { 348768, "d1e3826074ff1bfed02d93ab5ba1f5212a91de11b9f0a59d60a3d7cad283baa3", 1464270970, 0x01040000u },
    { 350784, "d0ed131c19242a7fac7c4c934f1cdef930b60d276e9925edfee0746397b1de41", 1464364025, 0x01060000u },
    { 352800, "2c4488eb9554ff59cefb3b87bd1145128299c6147c6c7350c82075e959fc469c", 1464448256, 0x01090000u },
    { 354816, "13da26047724ff7336805a59be700d78b10a92f500e39c4a57630ae303741eef", 1464590439, 0x01070000u },
    { 356832, "c54e005134ce734d057c46d90b91d28c96c0a456f5565bb021418b0fbc990ac4", 1464709839, 0x01070000u },
    { 358848, "05ce2ffff24c190eae2640b4d0e4f9ba14f54ede0631172de7f49030a0c8ab0d", 1464805678, 0x010a0000u },
    { 360864, "2948e78a9009a21276a2ae9f64ad3ad38e466be0347a944f132153c05a3c9c01", 1464932520, 0x01090000u },
    { 362880, "8e1933da341b85d90be04df82ad4bc66117c14f45b000a179d04f717a46b9905", 1465032153, 0x010b0000u },
    { 364896, "591ed2f7160d58f3eb2909837466c688add4e2f14d2fd85e520eeeae7fd54fec", 1465158398, 0x010b0000u },
    { 366912, "eb918aa7ca706031fb720c4799b6da9c7641e060f576a9a15085df9ebbbe7dda", 1465328108, 0x01070000u },
    { 368928, "c2060572ca95d1ab4ba7c41084bc0418c0d9ed10e69f1a8b98a3fe9e1595ed30", 1465427012, 0x01090000u },
    { 370944, "cf59809b463ce0d80c47ebafc349c8a480b9237e6dab6dc16c7e4e641e17bbc0", 1465508639, 0x010e0000u },
    { 372960, "af8b38c94bb773e5e6be63641c51fb1641139dd8b4ad527606d20b4598cdcf9b", 1465589575, 0x01150000u },
    { 374976, "9d402a9d4f80036e8b2da0923707074c6ecf7c7280e556b5c7d940caf976d021", 1465695339, 0x01190000u },
    { 376992, "87a2f2dfe6a8d032c52820d24b0a56f10bda5b23ed6ab0bbcbf7e77fa4ccc1d1", 1465835776, 0x01150000u },
    { 379008, "a89d4df39572a98615cee5891e8bbaa54fa0ceb329005382aff8e6c0e74ea9e8", 1465924013, 0x011e0000u },
    { 381024, "335b83d5846b0bd41ab88e0c57f0e459f94b612bfe0e89b3690421dd2f607ad9", 1466031168, 0x01220000u },
    { 383040, "0191acfbefa7077b8f13a71b3e8270767689a90c5bfc9336958f4ff1c0292e95", 1466175864, 0x011c0000u },
    { 385056, "a4bcb379c7d88cd1271693ddd5016c19a16694d58c1db3901fb0ebc2658b2a46", 1466278255, 0x01230000u },
    { 387072, "97b1db48486f51a87585b37d206c22d9f7d1d78f6c0214f6fc77b8615b9791e5", 1466418323, 0x011d0000u },
    { 389088, "f6e62b2fc939107788608385c231cbd7705521e50cbbebc6ca8b237445039063", 1466611712, 0x01120000u },
    { 391104, "53e17ba95b5e2d809d729bdb680b75a55d1ac9368af68354db1dd982080159c1", 1466703009, 0x01170000u },
    { 393120, "3d2d4a786763d7241ed86be67c6dab7f755ca7fd00c796d3011923529d636507", 1466803042, 0x011d0000u },
    { 395136, "ec7966afec60af7372fcbfc6b8a25346f5e31233b2126f288c7ba8795d9f5a45", 1466956773, 0x01170000u },
    { 397152, "fa1c43f90de1e98a23d38e0cc5bb6ae44396d0e0d3b16490d390739e336691ed", 1467052610, 0x011d0000u },
    { 399168, "b307787dfbd3b66444be8df77319e59ec6ad54c6ef1fcc19d7197fa27264da81", 1467185155, 0x011b0000u },
    { 401184, "5ff021760629ace7ec13b8cf8c20c74f448adb44aca75140453ee5149ce3f226", 1467347724, 0x01140000u },
    { 403200, "f02630e19fe9b7f30bd62634b85e678ad9ee607cea0d4ab7b0777800210be440", 1467462575, 0x01150000u },
    { 405216, "ab84040007d184371947d2e2c3fea0f604d2b5d1568966bad643687c5b3d96f4", 1467577343, 0x01150000u },
    { 407232, "063e5827f27a507d6002d129d47e320406cd528802495a9703ce21981f5aa36f", 1467667617, 0x011e0000u },
    { 409248, "f3ac66d39a298a571b88388b2ec7a3ab55bff9df7e175cc953a45a2fc991f9af", 1467804526, 0x011b0000u },
    { 411264, "a97bdbd099c6822b01964440d506a5df3772d607b11815eb5cf643ba66b36354", 1467915858, 0x011c0000u },
    { 413280, "a46101ad15d233dae7dd5b3f9dd29362a4d9719d8cec4e441b1d226aea93df82", 1468009453, 0x01250000u },
    { 415296, "54d0d3521c98581d95d6c1cfea7241ffb5ca4346eb19a3585e79a9b2be12ac6c", 1468106433, 0x012e0000u },
    { 417312, "079ccb30a46574e5c9e371e8acdc555592ac159406e1fec90a91a07d9c97b233", 1468213911, 0x01340000u },
    { 419328, "ed320dee148443388a43143d0e43d4f9ad903e5f975ab3a694ad1bef6f6fe0b8", 1468387863, 0x01250000u },
    { 421344, "26df786c19166f6d3099fe81c9dcd9a45c8ba636ef77ed66cc64094486974454", 1468524459, 0x01200000u },
    { 423360, "192f493f998d8ff3f3592e39547754dc78ca80568162856f8be4b309b659aac2", 1468648808, 0x011f0000u },
    { 425376, "78b84542ef73b61e8868fbc8d65ee85a1ea0ccba39485cbeb34db63bb87d5f7b", 1468778584, 0x011d0000u },
    { 427392, "dfacdafb7f7a95f181d809156ca335ff0087b4c90af1c86f8a11428609c57828", 1468899546, 0x011d0000u },
    { 429408, "5932ee9cec53d24c7fd0e8b8fb5d0200a9384d91af9f41901488cf9ed8dd0e33", 1469026777, 0x011f0000u },
    { 431424, "4e8d66ac3c5b3896357c633ce5abe997cf3f02a9e2e5c47af87d7c64e466df4f", 1469189962, 0x01150000u },
    { 433440, "9fdf35821ded237e3cf47048e1b3060929caec76e0bd4c61daf493040b6f69fa", 1469320107, 0x01140000u },
    { 435456, "642272e55c75a6fd500aa25b92939e5498f70bce3ee4082d608b07bf3353d447", 1469447219, 0x01130000u },
    { 437472, "f55e439d7665aa54e4fe96f6243f513b02f11e342be5b27cae3cdc60bfe83fe5", 1469602180, 0x010e0000u },
    { 439488, "7474a5339fdb2e528afeea24737307fc722816d70720b2e6c7353b23c5121253", 1469699952, 0x01120000u },
    { 441504, "d91e98d2cf270792c5d5013d58e22681d294a45dd2b12583776e77c90a9b055c", 1469829122, 0x01110000u },
    { 443520, "fe0b46998836aa6d25f98075b879aae0468c200444e329a4755650187b9cfb9c", 1469930538, 0x01130000u },
    { 445536, "47cf067417f6e02dc2d78da1e74c6e7cb64998c9228d32012df60799b650beb6", 1470053061, 0x01140000u },
    { 447552, "668385f5c5b889c2c9731ce477b687b59ea5f4c68140e0c4d17fcad82a19ecab", 1470225299, 0x010e0000u },
    { 449568, "57a4dcddd158ad32590fb064ab605ac5945f7d2cf3dc0f85c4719bf33f722643", 1470351882, 0x010c0000u },
    { 451584, "02877a9f51fe7ea3b9d9d40ef724a546dac921b549792bd21ffee8f77f1c11d4", 1470452435, 0x01150000u },
    { 453600, "34c1a35e416079c2cbad78ea3fb82bccab34825a1734c60a14cb2b0c34b85de6", 1470726280, 0x01080000u },
    { 455616, "f94a14b39b74b9336d924f0268af4e52490426105c6e6327de476d010836f9f7", 1470794185, 0x01100000u },
    { 457632, "e5c1b4f94ec0f5e900d7eddee899720da628f5cbb1a810578127e5b22f11f617", 1471014125, 0x01090000u },
    { 459648, "13b418bebb3eb259020bedf5ef99c4df3ceed5d647729632f85ee091beda76f4", 1471163205, 0x01070000u },
    { 461664, "f2bedc7bf91676ecc5589865e76e583f9508a19a0bf94e50c45a22377433f1f7", 1471248095, 0x010a0000u },
    { 463680, "ba195badb1913c1eacacf225e16c4d650756ba9001a8ed7c19ad846776d10bfe", 1471385294, 0x01090000u },
    { 465696, "eca1a98c80d8d2d884beeb4e32af7fd67ec6a63fef73b32cfedbeef210654218", 1471485704, 0x010b0000u },
    { 467712, "cdf7db49cf598837b1ca729971d9ff7ec5ddfc1db5f586feaa0b077accb1b5ce", 1471616595, 0x010a0000u },
    { 469728, "664ac1a35223bff5bf47bb7297efb9a81d63ea0a6bfb9b8640e0d96066cee554", 1471737335, 0x010a0000u },
    { 471744, "6e6ed0bb99f4f57460e3eaf624efc65154ee43b148c9ace305a4633293395ec0", 1471840167, 0x010d0000u },
    { 473760, "155bc66eb682fd820f7dda2e8b1dc9228950bf733986238ce84123cd76124139", 1472002506, 0x01090000u },
    { 475776, "09f92eba719a16fe96537db000916be760784980795394b553cfc4c9f73836d2", 1472088935, 0x010d0000u },
    { 477792, "6d7616c100bd07930433627a71d024c8218557054e9c91d9b4333d05c58891c2", 1472187973, 0x01100000u },
    { 479808, "e48a01b22e44e33b7aadb18a455d95818f403c2b173e72b48684ea700e3cac25", 1472321654, 0x010f0000u },
    { 481824, "bfb01e9d3f0f1f0ff903e5244f3494cd8ac1f32ad04351707b0437d70713740d", 1472420559, 0x01130000u },
    { 483840, "024ec6b096707c157ac7fd7d3d9cb5841dc90b345bd6c093426aa2aa1727c3fe", 1472580488, 0x010e0000u },
    { 485856, "f945eaa9ed606e65026cdeb5e792a2d82755f5c8fd4bcd936667e3c97c457caa", 1472676302, 0x01110000u },
    { 487872, "b1bba76f95562b20cb4b5fc58b0ad44f45cf8381318ee2fc62440de79572a7f3", 1472778052, 0x01150000u },
    { 489888, "db5622cdc91b76ef2edabe1118071d1ad85304a49bb758d0ae8bfcac10d9c228", 1472951520, 0x010f0000u },
    { 491904, "3099e137d2bb5e88457480831ce4a235657c774f7042426067d5e5467448b25b", 1473095808, 0x010c0000u },
    { 493920, "f47f6840542234d295ec9d5c891fae0e8081c06ff981a8e820b88245b3c563de", 1473213125, 0x010d0000u },
    { 495936, "70aad5a5c77f55d9f255dba91ffaa0b239f1671dead57fea02e09b8657993924", 1473330595, 0x010d0000u },
    { 497952, "736589347df774d6265118ac3d51c44a08be33c073deb194da0b36197adc3e16", 1473469819, 0x010b0000u },
    { 499968, "4ab0838bf7f9a90db00513527df6ec235381d278a97ee9d07bf9fc4dbb572d6d", 1473581519, 0x010c0000u },
    { 501984, "e5fc00938c520729fbfdec8f650170e155b567be49a4edd36708e4557d3c73c9", 1473678138, 0x010f0000u },
    { 504000, "bb8baecd61747ed1bf69bf198d0ea2fe98a327527b7bc94376dd5c034dd71866", 1473797849, 0x01100000u },
    { 506016, "735444c821e5e6e1c1881835720a5603f9b08f38529e4bbde4e3800ba8e5e992", 1473954235, 0x010c0000u },
    { 508032, "497089c5b88fc749dd1aae943e53b070d351e2a32bec01ac30ceabf61ffb3a50", 1474090798, 0x010a0000u },
    { 510048, "3e3e653816a8ac9c2203f640be4ba0706b5c9ada59122828490d8a4252b30b80", 1474238153, 0x01090000u },
    { 512064, "27443a52447bcc6b7db827895a608eb5ee8eecc1e6486a0de0b3292499a5623d", 1474362182, 0x01090000u },
    { 514080, "bba2557bbd88fdad773793a354688fde34eb63debcc3bac2b7ff61819c046bbd", 1474466313, 0x01090000u },
    { 516096, "c54573e968bc61e344ab7ce845f5da2ac0b782179c4defaf97c97374e0f7023d", 1474576233, 0x010a0000u },
    { 518112, "1c30317c165c00193fa9d2383d101ed85f1ff6e84b0844b8c5b63ba3f75d91c9", 1474677321, 0x010d0000u },
    { 520128, "d8e01250ce096a185f82468911b37500f2d20f046607ab3dd19ae8bbd9453e6b", 1474816853, 0x010b0000u },
    { 522144, "e6576b9da7812a31d67eefd9d6471177809b67af8bd410d089555e03e14308aa", 1474934560, 0x010b0000u },
    { 524160, "0182d355cc96635e7f1269150e0eac17ff2cd51defa7cea01f4fa93cb8fba155", 1475037724, 0x010f0000u },
    { 526176, "046b2c1e5b19b24c2c508e9eb7af849fe49be133d4424ca75f4b45f375f9d90c", 1475142453, 0x01100000u },
    { 528192, "4df7ebcd1ca9970af07f08ae22016aa45bafeee26d348abde5a60992a84d7f78", 1475222317, 0x01190000u },
    { 530208, "35007e3f505ebfe98c696ec4947240f09ece61529b3fa1b97bc8037a505faae1", 1475412281, 0x01100000u },
    { 532224, "e66a9730034a64ace9db2b47968139c6a87d3204c4e48a2072c2121762916c79", 1475513454, 0x01130000u },
    { 534240, "a37dbcf9617e891a7e1f5174b17d7b0f20abab21010db477c71cd091f95d6879", 1475652102, 0x01110000u },
    { 536256, "779181d412f078962c5b2444ef38d4a39a5b01d59a91b53a567f089ee19f6fee", 1475750292, 0x01150000u },
    { 538272, "f09bb96cc26dad4bfd68f771325227a167db70afa0bd71c7d25408bace75b1cd", 1475870707, 0x01150000u },
    { 540288, "169ac4cfb774ea15d020520cfbe0e698afd29e2fab55bc80d8b3864428e4f213", 1475990137, 0x01150000u },
    { 542304, "0a8e2d246c6bebae5a85a96dfab53ea69adc78c74b9f9c9bbaa4884dd6b79f18", 1476141777, 0x01100000u },
    { 544320, "6ac1c55597cd535e53456b6daba7175c49a822a6f25e782afc089b1ba32bac63", 1476239129, 0x01150000u },
    { 546336, "e688a362bf5849672011d4dcb30ea1f86242485ec64c290ac1d51231e95a3cfb", 1476396209, 0x01110000u },
    { 548352, "0aad674b108efbc22ece8250ba16e1c0671e8806c0831ef2b49b68c7d9237c71", 1476574947, 0x010b0000u },
    { 550368, "f00652079ccfd04e805a8f86a96ea66fafcf5337f8dc60ff29b9c9932fb40ede", 1476669320, 0x010f0000u },
    { 552384, "979f77ef344a08b5c6e0a9db88cb3539278936bd348bd46291553ee9e90befa9", 1476794563, 0x010e0000u },
    { 554400, "5c3884ceb9cce948283aa0f8c804b5c52c945e4b1d214b12773d944d18577005", 1476872628, 0x01150000u },
    { 556416, "52454c334d5549ac85fda60b1f7202649090e00055f6cb58af2a66d2a0ddd0b2", 1476942226, 0x01260000u },
    { 558432, "d0251d84943668eeb0d83b06983dc21c32425db4633acf3af6c42a44ed658721", 1477146736, 0x01180000u },
    { 560448, "2b0bc47fe1ed5f3c545e8d864f6d4e352835a37366a416cec3168e939752be3c", 1477365685, 0x010c0000u },
    { 562464, "a7e92fae6311b15b95dbbc45ced695d68da07d42c4b780ecb06f02b678fdbb9d", 1477412941, 0x01220000u },
    { 564480, "9f58915ccbebdc6d0f365101eb2d1e6dc803c3acae1d0e1480f46c3e158fd2a7", 1477612416, 0x01160000u },
    { 566496, "b7f2917e7459d7ca1b325e91fd32dec70cea27a3eec12ef0cf9ce7651b14e53f", 1477869593, 0x010a0000u },
    { 568512, "eee9c26e071f061428bf51de11e832a2f4036b0d39cafe2ef752243d711ed171", 1478022756, 0x01080000u },
    { 570528, "13e17b77940e0dfdc4073f9a96ce9205b62ed5a7fcff849d250453211edd4d43", 1478240346, 0x01040000u },
    { 572544, "0fc4e317d8073db6e7f2713daacb5a66d7c278e1404593ad37e237279f37e1bc", 1478338197, 0x01050000u },
    { 574560, "daa8e6804e7c7cbbdf7706eb3e3f7485a4d939f6354b8d1e46439af211fd1b39", 1478441400, 0x01070000u },
    { 576576, "4274343b4d09f496c884c5abbaae38eb785a97f6fe0766df3c0963d94679a4a2", 1478526971, 0x01080000u },
    { 578592, "9b35d229a693d68a873c1040a25c5339f67a53a4b0028db8ed8a99b27c9dd194", 1478579728, 0x011a0000u },
    { 580608, "5789bc3adae44b83323601f3313876213f4ad9e4d72687c534456b296138e52a", 1478843430, 0x010d0000u },
    { 582624, "eb5405b0ca2a301533846507896771ad4916ea449fd496be0a18a7b556269288", 1478946492, 0x010b0000u },
    { 584640, "76be27f56868bbb4a836a10829521fd8eb5c889da2150a39dca52e1e35c3d4ca", 1479203196, 0x01050000u },
    { 586656, "743a551b153bc2731d856435e0fd67055a6ca5b3e9e9c60d0c52767233f4a102", 1479312187, 0x01060000u },
    { 588672, "7b7bfa9508797f4f4eca9eb848fe4f072672b52e6e99ea43f9985ec0ddac1947", 1479407248, 0x01070000u },
    { 590688, "83444418c24531f8f01c4a935c190ed2dcb006fefec9f199ab83b45675ca637f", 1479515497, 0x01090000u },
    { 592704, "4bac1b206f43bb0677f4780968db5cd06e139689ac2d21a0162fdf14c8b90b76", 1479654737, 0x01070000u },
    { 594720, "817a75fcb2b321519b70724826669790a39ad3a9de1fe63093894af5fc49195b", 1479760481, 0x01090000u },
    { 596736, "32c2155a9be271e595e745fcf09eca428c6df3b393afdfa340130ab25215d59c", 1479927938, 0x01060000u },
    { 598752, "637cf5a10957f4f0cf33c745f21054c8bfedf08af4b48828b162285436861ad4", 1480042589, 0x01070000u },
    { 600768, "b03e033662fc43813e071e0b7a23ea7dd3b1b4fbfe3003315885ed11f1d04b95", 1480236391, 0x01040000u },
    { 602784, "47655ed6a02f6f76862047b384eb14c889885cbce30a4ae44cdb3daeaafa1762", 1480316850, 0x01060000u },
    { 604800, "09ddebc808e06266024b95a6469c8791aedd7a7992f1bbcb6a8af918570be20d", 1480387464, 0x010f0000u },
    { 606816, "a75a0c82008ee8e70f77f5637b2fa32354c483a36e6021ada2f1bd010f613116", 1480621957, 0x01070000u },
    { 608832, "d7c5b330afe8f753583c309e370ae944a4a51f104d82b651290ce450940279a5", 1480675965, 0x010e0000u },
    { 610848, "6bc277e9611b26899037a70b320bc6103159ea2f5064a3b1917cbceb971edb85", 1480773446, 0x01120000u },
    { 612864, "98801413c207a6b2a8ee889b581a50e4d72c35f1259d77e723f89cce0b5122cb", 1480869339, 0x011b0000u },
    { 614880, "597a0fd093b98c850d6ee7016abb5baea98f57247b0b88c005967e4aa79bd301", 1480980587, 0x011d0000u },
    { 616896, "a13e499bd8186035e120c3c0c4077ee663e6c7234b4867b80a48c6058e8a1ad0", 1481297580, 0x010a0000u },
    { 618912, "6c21b8540d3c0b583e47bff2800d1a9aa9de02733647806379e23c6e0672f5d6", 1481509171, 0x01060000u },
    { 620928, "ce1d75b92d90a0be6f4e21962f48eec9c16c466f30a0d919fc339e1e05cac1de", 1481558875, 0x01100000u },
    { 622944, "f0316c39c2080648323d3a458722a00ad131a682db5e3141d1f4f8e94f16ba88", 1481792260, 0x01080000u },
    { 624960, "f8ffa1ba21cd66bc7ad6e948dfe98ad06a7bb746ec54d7481a00caa2fcdb47ba", 1481857963, 0x01110000u },
    { 626976, "e0f691f3acdb84b0725a586a392b91788f793f66dfbf11ccca7b6e624fd9c250", 1481940485, 0x01200000u },
    { 628992, "e3541141e6d1bac9ae6abf2dfb4fb82bfb6320253bebc4cf2811b5c2b74119c2", 1482143493, 0x01100000u },
    { 631008, "e989559ac658f243383e86476956bca4fa56e0f89c94f8a67c779c1e8a967e6b", 1482236985, 0x01170000u },
    { 633024, "b76e1347561c012527d6a96d9dd1eb5e736bc559b8d8e6d23323d358a7e284d5", 1482408211, 0x01100000u },
    { 635040, "de37d2a4df661ef46b05de70e0fe5662e0f4ebbb451eb321eeaf1c13de2ff7d2", 1482621791, 0x01090000u },
    { 637056, "2d64b60c9db3773a269cf88e7610e38f59915fcf9562c1612c57c348ab0c0c69", 1482671969, 0x01180000u },
    { 639072, "7d9acc830093169fb77a9b4d052832ace6b5891404c15d61be5a2d6fc79ca757", 1482773566, 0x011e0000u },
    { 641088, "2e66949b91fb3418c5b2bfb44c3d43e466394c8e969849d061876e19ab429eec", 1482933811, 0x01160000u },
    { 643104, "8f7939fe2115da9a27e15d242255dc08ea41f25ad7d141128bc9fc7ada56e085", 1483010705, 0x01200000u },
    { 645120, "116f60e64d1950d520d33b864308636b0b1dba1523ac01d810d46415ac2c804e", 1483312673, 0x010f0000u },
    { 647136, "83791efe3365a9ae2270342fded5253fb0f8f7a21c84d562b02311332a679ffe", 1483347322, 0x01160000u },
    { 649152, "eb49b80d726e19b2da8bf0649efe3a2435163d3be5d34e98fdc8c171fda79cb3", 1483394141, 0x014c0000u },
    { 651168, "d759d929f81572c23a18fcd27f878235a446bb4e74a6defd7b07f5fb8146ea18", 1483503375, 0x01500000u },
    { 653184, "91169b8ce2c733e71582b5f27871ed59dcc509764affd5f43ec0db71b1fb46c1", 1483603796, 0x01620000u },
    { 655200, "6096f4dad976630f5ea1f913200cd152f31deffd651658485b112e6604974a95", 1483720867, 0x01640000u },
};

static const char *dns_seeds[] = {
    "dnsseed.mbl.cash", "dnsseed.mblcash.o11.pl", 
};

#endif

@interface BRPeerManager ()

@property (nonatomic, strong) NSMutableOrderedSet *peers;
@property (nonatomic, strong) NSMutableSet *connectedPeers, *misbehavinPeers, *nonFpTx;
@property (nonatomic, strong) BRPeer *downloadPeer;
@property (nonatomic, assign) uint32_t syncStartHeight, filterUpdateHeight;
@property (nonatomic, strong) BRBloomFilter *bloomFilter;
@property (nonatomic, assign) double fpRate;
@property (nonatomic, assign) NSUInteger taskId, connectFailures, misbehavinCount;
@property (nonatomic, assign) NSTimeInterval earliestKeyTime, lastRelayTime;
@property (nonatomic, strong) NSMutableDictionary *blocks, *orphans, *checkpoints, *txRelays, *txRequests;
@property (nonatomic, strong) NSMutableDictionary *publishedTx, *publishedCallback;
@property (nonatomic, strong) BRMerkleBlock *lastBlock, *lastOrphan;
@property (nonatomic, strong) dispatch_queue_t q;
@property (nonatomic, strong) id backgroundObserver, seedObserver;

@end

@implementation BRPeerManager

+ (instancetype)sharedInstance
{
    static id singleton = nil;
    static dispatch_once_t onceToken = 0;
    
    dispatch_once(&onceToken, ^{
        singleton = [self new];
    });
    
    return singleton;
}

- (instancetype)init
{
    if (! (self = [super init])) return nil;

    self.earliestKeyTime = [BRWalletManager sharedInstance].seedCreationTime;
    self.connectedPeers = [NSMutableSet set];
    self.misbehavinPeers = [NSMutableSet set];
    self.nonFpTx = [NSMutableSet set];
    self.taskId = UIBackgroundTaskInvalid;
    self.q = dispatch_queue_create("peermanager", NULL);
    self.orphans = [NSMutableDictionary dictionary];
    self.txRelays = [NSMutableDictionary dictionary];
    self.txRequests = [NSMutableDictionary dictionary];
    self.publishedTx = [NSMutableDictionary dictionary];
    self.publishedCallback = [NSMutableDictionary dictionary];

    self.backgroundObserver =
        [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil
        queue:nil usingBlock:^(NSNotification *note) {
            [self savePeers];
            [self saveBlocks];

            if (self.taskId == UIBackgroundTaskInvalid) {
                self.misbehavinCount = 0;
                [self.connectedPeers makeObjectsPerformSelector:@selector(disconnect)];
            }
        }];

    self.seedObserver =
        [[NSNotificationCenter defaultCenter] addObserverForName:BRWalletManagerSeedChangedNotification object:nil
        queue:nil usingBlock:^(NSNotification *note) {
            self.earliestKeyTime = [BRWalletManager sharedInstance].seedCreationTime;
            self.syncStartHeight = 0;
            [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:SYNC_STARTHEIGHT_KEY];
            [self.txRelays removeAllObjects];
            [self.publishedTx removeAllObjects];
            [self.publishedCallback removeAllObjects];
            [BRMerkleBlockEntity deleteObjects:[BRMerkleBlockEntity allObjects]];
            [BRMerkleBlockEntity saveContext];
            _blocks = nil;
            _bloomFilter = nil;
            _lastBlock = nil;
            [[self.connectedPeers copy] makeObjectsPerformSelector:@selector(disconnect)];
        }];

    return self;
}

- (void)dealloc
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    if (self.backgroundObserver) [[NSNotificationCenter defaultCenter] removeObserver:self.backgroundObserver];
    if (self.seedObserver) [[NSNotificationCenter defaultCenter] removeObserver:self.seedObserver];
}

- (NSMutableOrderedSet *)peers
{
    if (_peers.count >= PEER_MAX_CONNECTIONS) return _peers;

    @synchronized(self) {
        if (_peers.count >= PEER_MAX_CONNECTIONS) return _peers;
        _peers = [NSMutableOrderedSet orderedSet];

        [[BRPeerEntity context] performBlockAndWait:^{
            for (BRPeerEntity *e in [BRPeerEntity allObjects]) {
                @autoreleasepool {
                    if (e.misbehavin == 0) [_peers addObject:[e peer]];
                    else [self.misbehavinPeers addObject:[e peer]];
                }
            }
        }];

        [self sortPeers];

        // DNS peer discovery
        NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];
        NSMutableArray *peers = [NSMutableArray arrayWithObject:[NSMutableArray array]];

        if (_peers.count < PEER_MAX_CONNECTIONS ||
            ((BRPeer *)_peers[PEER_MAX_CONNECTIONS - 1]).timestamp + 3*24*60*60 < now) {
            while (peers.count < sizeof(dns_seeds)/sizeof(*dns_seeds)) [peers addObject:[NSMutableArray array]];
        }
        
        if (peers.count > 0) {
            dispatch_apply(peers.count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t i) {
                NSString *servname = @(BITCOIN_STANDARD_PORT).stringValue;
                struct addrinfo hints = { 0, AF_UNSPEC, SOCK_STREAM, 0, 0, 0, NULL, NULL }, *servinfo, *p;
                UInt128 addr = { .u32 = { 0, 0, CFSwapInt32HostToBig(0xffff), 0 } };

                NSLog(@"DNS lookup %s", dns_seeds[i]);
                
                if (getaddrinfo(dns_seeds[i], servname.UTF8String, &hints, &servinfo) == 0) {
                    for (p = servinfo; p != NULL; p = p->ai_next) {
                        if (p->ai_family == AF_INET) {
                            addr.u64[0] = 0;
                            addr.u32[2] = CFSwapInt32HostToBig(0xffff);
                            addr.u32[3] = ((struct sockaddr_in *)p->ai_addr)->sin_addr.s_addr;
                        }
//                        else if (p->ai_family == AF_INET6) {
//                            addr = *(UInt128 *)&((struct sockaddr_in6 *)p->ai_addr)->sin6_addr;
//                        }
                        else continue;
                        
                        uint16_t port = CFSwapInt16BigToHost(((struct sockaddr_in *)p->ai_addr)->sin_port);
                        NSTimeInterval age = 3*24*60*60 + arc4random_uniform(4*24*60*60); // add between 3 and 7 days
                    
                        [peers[i] addObject:[[BRPeer alloc] initWithAddress:addr port:port
                                             timestamp:(i > 0 ? now - age : now)
                                             services:SERVICES_NODE_NETWORK | SERVICES_NODE_BLOOM]];
                    }

                    freeaddrinfo(servinfo);
                }
            });
                        
            for (NSArray *a in peers) [_peers addObjectsFromArray:a];

#if BITCOIN_TESTNET
            [self sortPeers];
            return _peers;
#endif
            // if DNS peer discovery fails, fall back on a hard coded list of peers (list taken from satoshi client)
            if (_peers.count < PEER_MAX_CONNECTIONS) {
                UInt128 addr = { .u32 = { 0, 0, CFSwapInt32HostToBig(0xffff), 0 } };
            
                for (NSNumber *address in [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle]
                                           pathForResource:FIXED_PEERS ofType:@"plist"]]) {
                    // give hard coded peers a timestamp between 7 and 14 days ago
                    addr.u32[3] = CFSwapInt32HostToBig(address.unsignedIntValue);
                    [_peers addObject:[[BRPeer alloc] initWithAddress:addr port:BITCOIN_STANDARD_PORT
                     timestamp:now - (7*24*60*60 + arc4random_uniform(7*24*60*60))
                     services:SERVICES_NODE_NETWORK | SERVICES_NODE_BLOOM]];
                }
            }
            
            [self sortPeers];
        }

        return _peers;
    }
}

- (NSMutableDictionary *)blocks
{
    if (_blocks.count > 0) return _blocks;

    [[BRMerkleBlockEntity context] performBlockAndWait:^{
        if (_blocks.count > 0) return;
        _blocks = [NSMutableDictionary dictionary];
        self.checkpoints = [NSMutableDictionary dictionary];

        for (int i = 0; i < CHECKPOINT_COUNT; i++) { // add checkpoints to the block collection
            UInt256 hash = *(UInt256 *)@(checkpoint_array[i].hash).hexToData.reverse.bytes;

            _blocks[uint256_obj(hash)] = [[BRMerkleBlock alloc] initWithBlockHash:hash version:1 prevBlock:UINT256_ZERO
                                          merkleRoot:UINT256_ZERO timestamp:checkpoint_array[i].timestamp
                                          target:checkpoint_array[i].target nonce:0 totalTransactions:0 hashes:nil
                                                                            flags:nil height:checkpoint_array[i].height parentBlock:nil];
            self.checkpoints[@(checkpoint_array[i].height)] = uint256_obj(hash);
        }

        for (BRMerkleBlockEntity *e in [BRMerkleBlockEntity allObjects]) {
            @autoreleasepool {
                BRMerkleBlock *b = e.merkleBlock;

                if (b) _blocks[uint256_obj(b.blockHash)] = b;
            }
        };
    }];

    return _blocks;
}

// this is used as part of a getblocks or getheaders request
- (NSArray *)blockLocatorArray
{
    // append 10 most recent block hashes, decending, then continue appending, doubling the step back each time,
    // finishing with the genesis block (top, -1, -2, -3, -4, -5, -6, -7, -8, -9, -11, -15, -23, -39, -71, -135, ..., 0)
    NSMutableArray *locators = [NSMutableArray array];
    int32_t step = 1, start = 0;
    BRMerkleBlock *b = self.lastBlock;

    while (b && b.height > 0) {
        [locators addObject:uint256_obj(b.blockHash)];
        if (++start >= 10) step *= 2;

        for (int32_t i = 0; b && i < step; i++) {
            b = self.blocks[uint256_obj(b.prevBlock)];
        }
    }

    [locators addObject:uint256_obj(GENESIS_BLOCK_HASH)];
    return locators;
}

- (BRMerkleBlock *)lastBlock
{
    if (! _lastBlock) {
        NSFetchRequest *req = [BRMerkleBlockEntity fetchReq];

        req.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@"height" ascending:NO]];
        req.predicate = [NSPredicate predicateWithFormat:@"height >= 0 && height != %d", BLOCK_UNKNOWN_HEIGHT];
        req.fetchLimit = 1;
        _lastBlock = [[BRMerkleBlockEntity fetchObjects:req].lastObject merkleBlock];
        
        // if we don't have any blocks yet, use the latest checkpoint that's at least a week older than earliestKeyTime
        for (int i = CHECKPOINT_COUNT - 1; ! _lastBlock && i >= 0; i--) {
            if (i == 0 || checkpoint_array[i].timestamp + 7*24*60*60 < self.earliestKeyTime + NSTimeIntervalSince1970) {
                UInt256 hash = *(UInt256 *)@(checkpoint_array[i].hash).hexToData.reverse.bytes;
                
                _lastBlock = [[BRMerkleBlock alloc] initWithBlockHash:hash version:1 prevBlock:UINT256_ZERO
                              merkleRoot:UINT256_ZERO timestamp:checkpoint_array[i].timestamp
                              target:checkpoint_array[i].target nonce:0 totalTransactions:0 hashes:nil flags:nil
                                                               height:checkpoint_array[i].height parentBlock:nil];
            }
        }
        
        if (_lastBlock.height > _estimatedBlockHeight) _estimatedBlockHeight = _lastBlock.height;
    }
    
    return _lastBlock;
}

- (uint32_t)lastBlockHeight
{
    return self.lastBlock.height;
}

- (double)syncProgress
{
    if (! self.downloadPeer && self.syncStartHeight == 0) return 0.0;
    if (self.downloadPeer.status != BRPeerStatusConnected) return 0.05;
    if (self.lastBlockHeight >= self.estimatedBlockHeight) return 1.0;
    return 0.1 + 0.9*(self.lastBlockHeight - self.syncStartHeight)/(self.estimatedBlockHeight - self.syncStartHeight);
}

// number of connected peers
- (NSUInteger)peerCount
{
    NSUInteger count = 0;

    for (BRPeer *peer in [self.connectedPeers copy]) {
        if (peer.status == BRPeerStatusConnected) count++;
    }

    return count;
}

- (NSString *)downloadPeerName
{
    return [self.downloadPeer.host stringByAppendingFormat:@":%d", self.downloadPeer.port];
}

- (BRBloomFilter *)bloomFilterForPeer:(BRPeer *)peer
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    
    // every time a new wallet address is added, the bloom filter has to be rebuilt, and each address is only used for
    // one transaction, so here we generate some spare addresses to avoid rebuilding the filter each time a wallet
    // transaction is encountered during the blockchain download
    [manager.wallet addressesWithGapLimit:SEQUENCE_GAP_LIMIT_EXTERNAL + 100 internal:NO];
    [manager.wallet addressesWithGapLimit:SEQUENCE_GAP_LIMIT_INTERNAL + 100 internal:YES];

    [self.orphans removeAllObjects]; // clear out orphans that may have been received on an old filter
    self.lastOrphan = nil;
    self.filterUpdateHeight = self.lastBlockHeight;
    self.fpRate = BLOOM_REDUCED_FALSEPOSITIVE_RATE;

    BRUTXO o;
    NSData *d;
    NSSet *addresses = [manager.wallet.allReceiveAddresses setByAddingObjectsFromSet:manager.wallet.allChangeAddresses];
    NSUInteger i, elemCount = addresses.count + manager.wallet.unspentOutputs.count;
    NSMutableArray *inputs = [NSMutableArray new];

    for (BRTransaction *tx in manager.wallet.allTransactions) { // find TXOs spent within the last 100 blocks
        [self addTransactionToPublishList:tx]; // also populate the tx publish list
        if (tx.blockHeight != TX_UNCONFIRMED && tx.blockHeight + 100 < self.lastBlockHeight) break;
        i = 0;
        
        for (NSValue *hash in tx.inputHashes) {
            [hash getValue:&o.hash];
            o.n = [tx.inputIndexes[i++] unsignedIntValue];
            
            BRTransaction *t = [manager.wallet transactionForHash:o.hash];
            
            if (o.n < t.outputAddresses.count && [manager.wallet containsAddress:t.outputAddresses[o.n]]) {
                [inputs addObject:brutxo_data(o)];
                elemCount++;
            }
        }
    }
    
    BRBloomFilter *filter = [[BRBloomFilter alloc] initWithFalsePositiveRate:self.fpRate
                             forElementCount:(elemCount < 200 ? 300 : elemCount + 100) tweak:(uint32_t)peer.hash
                             flags:BLOOM_UPDATE_ALL];

    for (NSString *addr in addresses) {// add addresses to watch for tx receiveing money to the wallet
        NSData *hash = addr.addressToHash160;

        if (hash && ! [filter containsData:hash]) [filter insertData:hash];
    }

    for (NSValue *utxo in manager.wallet.unspentOutputs) { // add UTXOs to watch for tx sending money from the wallet
        [utxo getValue:&o];
        d = brutxo_data(o);
        if (! [filter containsData:d]) [filter insertData:d];
    }
    
    for (d in inputs) { // also add TXOs spent within the last 100 blocks
        if (! [filter containsData:d]) [filter insertData:d];
    }
    
    // TODO: XXXX if already synced, recursively add inputs of unconfirmed receives
    _bloomFilter = filter;
    return _bloomFilter;
}

- (void)connect
{
    dispatch_async(self.q, ^{
        if ([BRWalletManager sharedInstance].noWallet) return; // check to make sure the wallet has been created
        if (self.connectFailures >= MAX_CONNECT_FAILURES) self.connectFailures = 0; // this attempt is a manual retry
    
        if (self.syncProgress < 1.0) {
            if (self.syncStartHeight == 0) {
                self.syncStartHeight = (uint32_t)[[NSUserDefaults standardUserDefaults]
                                                  integerForKey:SYNC_STARTHEIGHT_KEY];
            }
            
            if (self.syncStartHeight == 0) {
                self.syncStartHeight = self.lastBlockHeight;
                [[NSUserDefaults standardUserDefaults] setInteger:self.syncStartHeight forKey:SYNC_STARTHEIGHT_KEY];
            }

            if (self.taskId == UIBackgroundTaskInvalid) { // start a background task for the chain sync
                self.taskId =
                    [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
                        dispatch_async(self.q, ^{
                            [self saveBlocks];
                        });

                        [self syncStopped];
                    }];
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerSyncStartedNotification
                 object:nil];
            });
        }

        [self.connectedPeers minusSet:[self.connectedPeers objectsPassingTest:^BOOL(id obj, BOOL *stop) {
            return ([obj status] == BRPeerStatusDisconnected) ? YES : NO;
        }]];

        if (self.connectedPeers.count >= PEER_MAX_CONNECTIONS) return; //already connected to PEER_MAX_CONNECTIONS peers

        NSMutableOrderedSet *peers = [NSMutableOrderedSet orderedSetWithOrderedSet:self.peers];

        if (peers.count > 100) [peers removeObjectsInRange:NSMakeRange(100, peers.count - 100)];

        while (peers.count > 0 && self.connectedPeers.count < PEER_MAX_CONNECTIONS) {
            // pick a random peer biased towards peers with more recent timestamps
            BRPeer *p = peers[(NSUInteger)(pow(arc4random_uniform((uint32_t)peers.count), 2)/peers.count)];

            if (p && ! [self.connectedPeers containsObject:p]) {
                [p setDelegate:self queue:self.q];
                p.earliestKeyTime = self.earliestKeyTime;
                [self.connectedPeers addObject:p];
                [p connect];
            }

            [peers removeObject:p];
        }

        if (self.connectedPeers.count == 0) {
            [self syncStopped];

            dispatch_async(dispatch_get_main_queue(), ^{
                NSError *error = [NSError errorWithDomain:@"BreadWallet" code:1
                                  userInfo:@{NSLocalizedDescriptionKey:NSLocalizedString(@"no peers found", nil)}];

                [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerSyncFailedNotification
                 object:nil userInfo:@{@"error":error}];
            });
        }
    });
}

// rescans blocks and transactions after earliestKeyTime, a new random download peer is also selected due to the
// possibility that a malicious node might lie by omitting transactions that match the bloom filter
- (void)rescan
{
    if (! self.connected) return;

    dispatch_async(self.q, ^{
        _lastBlock = nil;

        // start the chain download from the most recent checkpoint that's at least a week older than earliestKeyTime
        for (int i = CHECKPOINT_COUNT - 1; ! _lastBlock && i >= 0; i--) {
            if (i == 0 || checkpoint_array[i].timestamp + 7*24*60*60 < self.earliestKeyTime + NSTimeIntervalSince1970) {
                UInt256 hash = *(UInt256 *)@(checkpoint_array[i].hash).hexToData.reverse.bytes;

                _lastBlock = self.blocks[uint256_obj(hash)];
            }
        }

        if (self.downloadPeer) { // disconnect the current download peer so a new random one will be selected
            [self.peers removeObject:self.downloadPeer];
            [self.downloadPeer disconnect];
        }

        self.syncStartHeight = self.lastBlockHeight;
        [[NSUserDefaults standardUserDefaults] setInteger:self.syncStartHeight forKey:SYNC_STARTHEIGHT_KEY];
        [self connect];
    });
}

// adds transaction to list of tx to be published, along with any unconfirmed inputs
- (void)addTransactionToPublishList:(BRTransaction *)transaction
{
    if (transaction.blockHeight == TX_UNCONFIRMED) {
        NSLog(@"[BRPeerManager] add transaction to publish list %@", transaction);
        self.publishedTx[uint256_obj(transaction.txHash)] = transaction;
    
        for (NSValue *hash in transaction.inputHashes) {
            UInt256 h = UINT256_ZERO;
            
            [hash getValue:&h];
            [self addTransactionToPublishList:[[BRWalletManager sharedInstance].wallet transactionForHash:h]];
        }
    }
}

- (void)publishTransaction:(BRTransaction *)transaction completion:(void (^)(NSError *error))completion
{
    NSLog(@"[BRPeerManager] publish transaction %@", transaction);
    if (! transaction.isSigned) {
        if (completion) {
            [[BREventManager sharedEventManager] saveEvent:@"peer_manager:not_signed"];
            completion([NSError errorWithDomain:@"BreadWallet" code:401 userInfo:@{NSLocalizedDescriptionKey:
                        NSLocalizedString(@"mobilecash transaction not signed", nil)}]);
        }
        
        return;
    }
    else if (! self.connected && self.connectFailures >= MAX_CONNECT_FAILURES) {
        if (completion) {
            [[BREventManager sharedEventManager] saveEvent:@"peer_manager:not_connected"];
            completion([NSError errorWithDomain:@"BreadWallet" code:-1009 userInfo:@{NSLocalizedDescriptionKey:
                        NSLocalizedString(@"not connected to the mobilecash network", nil)}]);
        }
        
        return;
    }

    NSMutableSet *peers = [NSMutableSet setWithSet:self.connectedPeers];
    NSValue *hash = uint256_obj(transaction.txHash);
    
    [self addTransactionToPublishList:transaction];
    if (completion) self.publishedCallback[hash] = completion;

    NSArray *txHashes = self.publishedTx.allKeys;

    // instead of publishing to all peers, leave out the download peer to see if the tx propogates and gets relayed back
    // TODO: XXX connect to a random peer with an empty or fake bloom filter just for publishing
    if (self.peerCount > 1 && self.downloadPeer) [peers removeObject:self.downloadPeer];

    dispatch_async(dispatch_get_main_queue(), ^{
        [self performSelector:@selector(txTimeout:) withObject:hash afterDelay:PROTOCOL_TIMEOUT];

        for (BRPeer *p in peers) {
            if (p.status != BRPeerStatusConnected) continue;
            [p sendInvMessageWithTxHashes:txHashes];
            [p sendPingMessageWithPongHandler:^(BOOL success) {
                if (! success) return;

                for (NSValue *h in txHashes) {
                    if ([self.txRelays[h] containsObject:p] || [self.txRequests[h] containsObject:p]) continue;
                    if (! self.txRequests[h]) self.txRequests[h] = [NSMutableSet set];
                    [self.txRequests[h] addObject:p];
                    [p sendGetdataMessageWithTxHashes:@[h] andBlockHashes:nil];
                }
            }];
        }
    });
}

// number of connected peers that have relayed the transaction
- (NSUInteger)relayCountForTransaction:(UInt256)txHash
{
    return [self.txRelays[uint256_obj(txHash)] count];
}

// seconds since reference date, 00:00:00 01/01/01 GMT
// NOTE: this is only accurate for the last two weeks worth of blocks, other timestamps are estimated from checkpoints
- (NSTimeInterval)timestampForBlockHeight:(uint32_t)blockHeight
{
    if (blockHeight == TX_UNCONFIRMED) return (self.lastBlock.timestamp - NSTimeIntervalSince1970) + 10*60; //next block

    if (blockHeight >= self.lastBlockHeight) { // future block, assume 10 minutes per block after last block
        return (self.lastBlock.timestamp - NSTimeIntervalSince1970) + (blockHeight - self.lastBlockHeight)*10*60;
    }

    if (_blocks.count > 0) {
        if (blockHeight >= self.lastBlockHeight - nInterval*2) { // recent block we have the header for
            BRMerkleBlock *block = self.lastBlock;

            while (block && block.height > blockHeight) block = self.blocks[uint256_obj(block.prevBlock)];
            if (block) return block.timestamp - NSTimeIntervalSince1970;
        }
    }
    else [[BRMerkleBlockEntity context] performBlock:^{ [self blocks]; }];

    uint32_t h = self.lastBlockHeight, t = self.lastBlock.timestamp;

    for (int i = CHECKPOINT_COUNT - 1; i >= 0; i--) { // estimate from checkpoints
        if (checkpoint_array[i].height <= blockHeight) {
            t = checkpoint_array[i].timestamp + (t - checkpoint_array[i].timestamp)*
                (blockHeight - checkpoint_array[i].height)/(h - checkpoint_array[i].height);
            return t - NSTimeIntervalSince1970;
        }

        h = checkpoint_array[i].height;
        t = checkpoint_array[i].timestamp;
    }

    return checkpoint_array[0].timestamp - NSTimeIntervalSince1970;
}

- (void)setBlockHeight:(int32_t)height andTimestamp:(NSTimeInterval)timestamp forTxHashes:(NSArray *)txHashes
{
    NSArray *updatedTx = [[BRWalletManager sharedInstance].wallet setBlockHeight:height andTimestamp:timestamp
                          forTxHashes:txHashes];
    
    if (height != TX_UNCONFIRMED) { // remove confirmed tx from publish list and relay counts
        [self.publishedTx removeObjectsForKeys:txHashes];
        [self.publishedCallback removeObjectsForKeys:txHashes];
        [self.txRelays removeObjectsForKeys:txHashes];
    }
    
    for (NSValue *hash in updatedTx) {
        NSError *kvErr = nil;
        BRTxMetadataObject *txm;
        UInt256 h;
        
        [hash getValue:&h];
        txm = [[BRTxMetadataObject alloc] initWithTxHash:h store:[BRAPIClient sharedClient].kv];
        txm.blockHeight = height;
        if (txm) [[BRAPIClient sharedClient].kv set:txm error:&kvErr];
    }
}

- (void)txTimeout:(NSValue *)txHash
{
    void (^callback)(NSError *error) = self.publishedCallback[txHash];

    [self.publishedTx removeObjectForKey:txHash];
    [self.publishedCallback removeObjectForKey:txHash];
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(txTimeout:) object:txHash];

    if (callback) {
        [[BREventManager sharedEventManager] saveEvent:@"peer_manager:tx_canceled_timeout"];
        callback([NSError errorWithDomain:@"BreadWallet" code:BITCOIN_TIMEOUT_CODE userInfo:@{NSLocalizedDescriptionKey:
                  NSLocalizedString(@"transaction canceled, network timeout", nil)}]);
    }
}

- (void)syncTimeout
{
    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];

    if (now - self.lastRelayTime < PROTOCOL_TIMEOUT) { // the download peer relayed something in time, so restart timer
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(syncTimeout) object:nil];
        [self performSelector:@selector(syncTimeout) withObject:nil
         afterDelay:PROTOCOL_TIMEOUT - (now - self.lastRelayTime)];
        return;
    }

    dispatch_async(self.q, ^{
        if (! self.downloadPeer) return;
        NSLog(@"%@:%d chain sync timed out", self.downloadPeer.host, self.downloadPeer.port);
        [self.peers removeObject:self.downloadPeer];
        [self.downloadPeer disconnect];
    });
}

- (void)syncStopped
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(syncTimeout) object:nil];

        if (self.taskId != UIBackgroundTaskInvalid) {
            [[UIApplication sharedApplication] endBackgroundTask:self.taskId];
            self.taskId = UIBackgroundTaskInvalid;
        }
    });
}

- (void)loadMempools
{
    for (BRPeer *p in self.connectedPeers) { // after syncing, load filters and get mempools from other peers
        if (p.status != BRPeerStatusConnected) continue;
        
        if (p != self.downloadPeer || self.fpRate > BLOOM_REDUCED_FALSEPOSITIVE_RATE*5.0) {
            [p sendFilterloadMessage:[self bloomFilterForPeer:p].data];
        }
        
        [p sendInvMessageWithTxHashes:self.publishedCallback.allKeys]; // publish pending tx
        [p sendPingMessageWithPongHandler:^(BOOL success) {
            if (success) {
                [p sendMempoolMessage:self.publishedTx.allKeys completion:^(BOOL success) {
                    if (success) {
                        p.synced = YES;
                        [self removeUnrelayedTransactions];
                        [p sendGetaddrMessage]; // request a list of other bitcoin peers
                        
                        dispatch_async(dispatch_get_main_queue(), ^{
                            [[NSNotificationCenter defaultCenter]
                             postNotificationName:BRPeerManagerTxStatusNotification object:nil];
                        });
                    }
                    
                    if (p == self.downloadPeer) {
                        [self syncStopped];

                        dispatch_async(dispatch_get_main_queue(), ^{
                            [[NSNotificationCenter defaultCenter]
                             postNotificationName:BRPeerManagerSyncFinishedNotification object:nil];
                        });
                    }
                }];
            }
            else if (p == self.downloadPeer) {
                [self syncStopped];

                dispatch_async(dispatch_get_main_queue(), ^{
                    [[NSNotificationCenter defaultCenter]
                     postNotificationName:BRPeerManagerSyncFinishedNotification object:nil];
                });
            }
        }];
    }
}

// unconfirmed transactions that aren't in the mempools of any of connected peers have likely dropped off the network
- (void)removeUnrelayedTransactions
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    BOOL rescan = NO, notify = NO;
    NSValue *hash;
    UInt256 h;

    // don't remove transactions until we're connected to PEER_MAX_CONNECTION peers
    if (self.peerCount < PEER_MAX_CONNECTIONS) return;
    
    for (BRPeer *p in self.connectedPeers) { // don't remove tx until all peers have finished relaying their mempools
        if (! p.synced) return;
    }

    for (BRTransaction *tx in manager.wallet.allTransactions) {
        if (tx.blockHeight != TX_UNCONFIRMED) break;
        hash = uint256_obj(tx.txHash);
        if (self.publishedCallback[hash] != NULL) continue;
        
        if ([self.txRelays[hash] count] == 0 && [self.txRequests[hash] count] == 0) {
            // if this is for a transaction we sent, and it wasn't already known to be invalid, notify user of failure
            if (! rescan && [manager.wallet amountSentByTransaction:tx] > 0 && [manager.wallet transactionIsValid:tx]) {
                NSLog(@"failed transaction %@", tx);
                rescan = notify = YES;
                
                for (NSValue *hash in tx.inputHashes) { // only recommend a rescan if all inputs are confirmed
                    [hash getValue:&h];
                    if ([manager.wallet transactionForHash:h].blockHeight != TX_UNCONFIRMED) continue;
                    rescan = NO;
                    break;
                }
            }
            
            [manager.wallet removeTransaction:tx.txHash];
        }
        else if ([self.txRelays[hash] count] < PEER_MAX_CONNECTIONS) {
            // set timestamp 0 to mark as unverified
            [self setBlockHeight:TX_UNCONFIRMED andTimestamp:0 forTxHashes:@[hash]];
        }
    }
    
    if (notify) {
        dispatch_async(dispatch_get_main_queue(), ^{
            if (rescan) {
                [[BREventManager sharedEventManager] saveEvent:@"peer_manager:tx_rejected_rescan"];
                [[[UIAlertView alloc] initWithTitle:NSLocalizedString(@"transaction rejected", nil)
                  message:NSLocalizedString(@"Your wallet may be out of sync.\n"
                                            "This can often be fixed by rescanning the blockchain.", nil) delegate:self
                  cancelButtonTitle:NSLocalizedString(@"cancel", nil)
                  otherButtonTitles:NSLocalizedString(@"rescan", nil), nil] show];
            }
            else {
                [[BREventManager sharedEventManager] saveEvent:@"peer_manager_tx_rejected"];
                [[[UIAlertView alloc] initWithTitle:NSLocalizedString(@"transaction rejected", nil)
                  message:nil delegate:nil cancelButtonTitle:NSLocalizedString(@"ok", nil) otherButtonTitles:nil] show];
            }
        });
    }
}

- (void)updateFilter
{
    if (self.downloadPeer.needsFilterUpdate) return;
    self.downloadPeer.needsFilterUpdate = YES;
    NSLog(@"filter update needed, waiting for pong");
    
    [self.downloadPeer sendPingMessageWithPongHandler:^(BOOL success) { // wait for pong so we include already sent tx
        if (! success) return;
        NSLog(@"updating filter with newly created wallet addresses");
        _bloomFilter = nil;

        if (self.lastBlockHeight < self.estimatedBlockHeight) { // if we're syncing, only update download peer
            [self.downloadPeer sendFilterloadMessage:[self bloomFilterForPeer:self.downloadPeer].data];
            [self.downloadPeer sendPingMessageWithPongHandler:^(BOOL success) { // wait for pong so filter is loaded
                if (! success) return;
                self.downloadPeer.needsFilterUpdate = NO;
                [self.downloadPeer rerequestBlocksFrom:self.lastBlock.blockHash];
                [self.downloadPeer sendPingMessageWithPongHandler:^(BOOL success) {
                    if (! success || self.downloadPeer.needsFilterUpdate) return;
                    [self.downloadPeer sendGetblocksMessageWithLocators:[self blockLocatorArray]
                     andHashStop:UINT256_ZERO];
                }];
            }];
        }
        else {
            for (BRPeer *p in self.connectedPeers) {
                if (p.status != BRPeerStatusConnected) continue;
                [p sendFilterloadMessage:[self bloomFilterForPeer:p].data];
                [p sendPingMessageWithPongHandler:^(BOOL success) { // wait for pong so we know filter is loaded
                    if (! success) return;
                    p.needsFilterUpdate = NO;
                    [p sendMempoolMessage:self.publishedTx.allKeys completion:nil];
                }];
            }
        }
    }];
}

- (void)peerMisbehavin:(BRPeer *)peer
{
    peer.misbehavin++;
    [self.peers removeObject:peer];
    [self.misbehavinPeers addObject:peer];

    if (++self.misbehavinCount >= 10) { // clear out stored peers so we get a fresh list from DNS for next connect
        self.misbehavinCount = 0;
        [self.misbehavinPeers removeAllObjects];
        [BRPeerEntity deleteObjects:[BRPeerEntity allObjects]];
        _peers = nil;
    }
    
    [peer disconnect];
    [self connect];
}

- (void)sortPeers
{
    [_peers sortUsingComparator:^NSComparisonResult(BRPeer *p1, BRPeer *p2) {
        if (p1.timestamp > p2.timestamp) return NSOrderedAscending;
        if (p1.timestamp < p2.timestamp) return NSOrderedDescending;
        return NSOrderedSame;
    }];
}

- (void)savePeers
{
    NSLog(@"[BRPeerManager] save peers");
    NSMutableSet *peers = [[self.peers.set setByAddingObjectsFromSet:self.misbehavinPeers] mutableCopy];
    NSMutableSet *addrs = [NSMutableSet set];

    for (BRPeer *p in peers) {
        if (p.address.u64[0] != 0 || p.address.u32[2] != CFSwapInt32HostToBig(0xffff)) continue; // skip IPv6 for now
        [addrs addObject:@(CFSwapInt32BigToHost(p.address.u32[3]))];
    }

    [[BRPeerEntity context] performBlock:^{
        [BRPeerEntity deleteObjects:[BRPeerEntity objectsMatching:@"! (address in %@)", addrs]]; // remove deleted peers

        for (BRPeerEntity *e in [BRPeerEntity objectsMatching:@"address in %@", addrs]) { // update existing peers
            @autoreleasepool {
                BRPeer *p = [peers member:[e peer]];
                
                if (p) {
                    e.timestamp = p.timestamp;
                    e.services = p.services;
                    e.misbehavin = p.misbehavin;
                    [peers removeObject:p];
                }
                else [e deleteObject];
            }
        }

        for (BRPeer *p in peers) {
            @autoreleasepool {
                [[BRPeerEntity managedObject] setAttributesFromPeer:p]; // add new peers
            }
        }
    }];
}

- (void)saveBlocks
{
    NSLog(@"[BRPeerManager] save blocks");
    NSMutableDictionary *blocks = [NSMutableDictionary dictionary];
    BRMerkleBlock *b = self.lastBlock;

    while (b) {
        blocks[[NSData dataWithBytes:b.blockHash.u8 length:sizeof(UInt256)]] = b;
        b = self.blocks[uint256_obj(b.prevBlock)];
    }

    [[BRMerkleBlockEntity context] performBlock:^{
        [BRMerkleBlockEntity deleteObjects:[BRMerkleBlockEntity objectsMatching:@"! (blockHash in %@)",
                                            blocks.allKeys]];

        for (BRMerkleBlockEntity *e in [BRMerkleBlockEntity objectsMatching:@"blockHash in %@", blocks.allKeys]) {
            @autoreleasepool {
                [e setAttributesFromBlock:blocks[e.blockHash]];
                [blocks removeObjectForKey:e.blockHash];
            }
        }

        for (BRMerkleBlock *b in blocks.allValues) {
            @autoreleasepool {
                [[BRMerkleBlockEntity managedObject] setAttributesFromBlock:b];
            }
        }
        
        [BRMerkleBlockEntity saveContext];
    }];
}

// MARK: - BRPeerDelegate

- (void)peerConnected:(BRPeer *)peer
{
    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];
    
    if (peer.timestamp > now + 2*60*60 || peer.timestamp < now - 2*60*60) peer.timestamp = now; //timestamp sanity check
    self.connectFailures = 0;
    NSLog(@"%@:%d connected with lastblock %d", peer.host, peer.port, peer.lastblock);
    
    // drop peers that don't carry full blocks, or aren't synced yet
    // TODO: XXXX does this work with 0.11 pruned nodes?
    if (! (peer.services & SERVICES_NODE_NETWORK) || peer.lastblock + 10 < self.lastBlockHeight) {
        [peer disconnect];
        return;
    }

    // drop peers that don't support SPV filtering
    if (peer.version >= 70011 && ! (peer.services & SERVICES_NODE_BLOOM)) {
        [peer disconnect];
        return;
    }

    if (self.connected && (self.estimatedBlockHeight >= peer.lastblock || self.lastBlockHeight >= peer.lastblock)) {
        if (self.lastBlockHeight < self.estimatedBlockHeight) return; // don't load bloom filter yet if we're syncing
        [peer sendFilterloadMessage:[self bloomFilterForPeer:peer].data];
        [peer sendInvMessageWithTxHashes:self.publishedCallback.allKeys]; // publish pending tx
        [peer sendPingMessageWithPongHandler:^(BOOL success) {
            if (! success) return;
            [peer sendMempoolMessage:self.publishedTx.allKeys completion:^(BOOL success) {
                if (! success) return;
                peer.synced = YES;
                [self removeUnrelayedTransactions];
                [peer sendGetaddrMessage]; // request a list of other bitcoin peers
                
                dispatch_async(dispatch_get_main_queue(), ^{
                    [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification
                     object:nil];
                });
            }];
        }];

        return; // we're already connected to a download peer
    }

    // select the peer with the lowest ping time to download the chain from if we're behind
    // BUG: XXX a malicious peer can report a higher lastblock to make us select them as the download peer, if two
    // peers agree on lastblock, use one of them instead
    for (BRPeer *p in self.connectedPeers) {
        if (p.status != BRPeerStatusConnected) continue;
        if ((p.pingTime < peer.pingTime && p.lastblock >= peer.lastblock) || p.lastblock > peer.lastblock) peer = p;
    }

    [self.downloadPeer disconnect];
    self.downloadPeer = peer;
    _connected = YES;
    _estimatedBlockHeight = peer.lastblock;
    [peer sendFilterloadMessage:[self bloomFilterForPeer:peer].data];
    peer.currentBlockHeight = self.lastBlockHeight;
    
    if (self.lastBlockHeight < peer.lastblock) { // start blockchain sync
        self.lastRelayTime = 0;
        
        dispatch_async(dispatch_get_main_queue(), ^{ // setup a timer to detect if the sync stalls
            [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(syncTimeout) object:nil];
            [self performSelector:@selector(syncTimeout) withObject:nil afterDelay:PROTOCOL_TIMEOUT];

            dispatch_async(self.q, ^{
                // request just block headers up to a week before earliestKeyTime, and then merkleblocks after that
                // BUG: XXX headers can timeout on slow connections (each message is over 160k)
                if (self.lastBlock.timestamp + 7*24*60*60 >= self.earliestKeyTime + NSTimeIntervalSince1970) {
                    [peer sendGetblocksMessageWithLocators:[self blockLocatorArray] andHashStop:UINT256_ZERO];
                }
                else [peer sendGetheadersMessageWithLocators:[self blockLocatorArray] andHashStop:UINT256_ZERO];
            });
        });
    }
    else { // we're already synced
        self.syncStartHeight = 0;
        [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:SYNC_STARTHEIGHT_KEY];
        [self loadMempools];
    }
}

- (void)peer:(BRPeer *)peer disconnectedWithError:(NSError *)error
{
    NSLog(@"%@:%d disconnected%@%@", peer.host, peer.port, (error ? @", " : @""), (error ? error : @""));
    
    if ([error.domain isEqual:@"BreadWallet"] && error.code != BITCOIN_TIMEOUT_CODE) {
        [self peerMisbehavin:peer]; // if it's protocol error other than timeout, the peer isn't following the rules
    }
    else if (error) { // timeout or some non-protocol related network error
        [self.peers removeObject:peer];
        self.connectFailures++;
    }

    for (NSValue *txHash in self.txRelays.allKeys) {
        [self.txRelays[txHash] removeObject:peer];
    }

    if ([self.downloadPeer isEqual:peer]) { // download peer disconnected
        _connected = NO;
        self.downloadPeer = nil;
        if (self.connectFailures > MAX_CONNECT_FAILURES) self.connectFailures = MAX_CONNECT_FAILURES;
    }

    if (! self.connected && self.connectFailures == MAX_CONNECT_FAILURES) {
        [self syncStopped];
        
        // clear out stored peers so we get a fresh list from DNS on next connect attempt
        [self.misbehavinPeers removeAllObjects];
        [BRPeerEntity deleteObjects:[BRPeerEntity allObjects]];
        _peers = nil;

        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerSyncFailedNotification
             object:nil userInfo:(error) ? @{@"error":error} : nil];
        });
    }
    else if (self.connectFailures < MAX_CONNECT_FAILURES && (self.taskId != UIBackgroundTaskInvalid ||
             [UIApplication sharedApplication].applicationState != UIApplicationStateBackground)) {
        [self connect]; // try connecting to another peer
    }
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
    });
}

- (void)peer:(BRPeer *)peer relayedPeers:(NSArray *)peers
{
    NSLog(@"%@:%d relayed %d peer(s)", peer.host, peer.port, (int)peers.count);
    [self.peers addObjectsFromArray:peers];
    [self.peers minusSet:self.misbehavinPeers];
    [self sortPeers];

    // limit total to 2500 peers
    if (self.peers.count > 2500) [self.peers removeObjectsInRange:NSMakeRange(2500, self.peers.count - 2500)];

    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];

    // remove peers more than 3 hours old, or until there are only 1000 left
    while (self.peers.count > 1000 && ((BRPeer *)self.peers.lastObject).timestamp + 3*60*60 < now) {
        [self.peers removeObject:self.peers.lastObject];
    }

    if (peers.count > 1 && peers.count < 1000) [self savePeers]; // peer relaying is complete when we receive <1000
}

- (void)peer:(BRPeer *)peer relayedTransaction:(BRTransaction *)transaction
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    NSValue *hash = uint256_obj(transaction.txHash);
    BOOL syncing = (self.lastBlockHeight < self.estimatedBlockHeight);
    void (^callback)(NSError *error) = self.publishedCallback[hash];

    NSLog(@"%@:%d relayed transaction %@", peer.host, peer.port, hash);
    
    transaction.timestamp = [NSDate timeIntervalSinceReferenceDate];
    if (syncing && ! [manager.wallet containsTransaction:transaction]) return;
    if (! [manager.wallet registerTransaction:transaction]) return;
    if (peer == self.downloadPeer) self.lastRelayTime = [NSDate timeIntervalSinceReferenceDate];

    if ([manager.wallet amountSentByTransaction:transaction] > 0 && [manager.wallet transactionIsValid:transaction]) {
        [self addTransactionToPublishList:transaction]; // add valid send tx to mempool
    }
    
    // keep track of how many peers have or relay a tx, this indicates how likely the tx is to confirm
    if (callback || (! syncing && ! [self.txRelays[hash] containsObject:peer])) {
        if (! self.txRelays[hash]) self.txRelays[hash] = [NSMutableSet set];
        [self.txRelays[hash] addObject:peer];
        if (callback) [self.publishedCallback removeObjectForKey:hash];

        if ([self.txRelays[hash] count] >= PEER_MAX_CONNECTIONS &&
            [manager.wallet transactionForHash:transaction.txHash].blockHeight == TX_UNCONFIRMED &&
            [manager.wallet transactionForHash:transaction.txHash].timestamp == 0) {
            [self setBlockHeight:TX_UNCONFIRMED andTimestamp:[NSDate timeIntervalSinceReferenceDate]
             forTxHashes:@[hash]]; // set timestamp when tx is verified
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            NSError *kvErr = nil;
            
            [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(txTimeout:) object:hash];
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
            if (callback) callback(nil);
            
            [[BRAPIClient sharedClient].kv
             set:[[BRTxMetadataObject alloc] initWithTransaction:transaction exchangeRate:manager.localCurrencyPrice
                  exchangeRateCurrency:manager.localCurrencyCode feeRate:manager.wallet.feePerKb
                  deviceId:[BRAPIClient sharedClient].deviceId] error:&kvErr];
        });
    }
    
    [self.nonFpTx addObject:hash];
    [self.txRequests[hash] removeObject:peer];
    if (! _bloomFilter) return; // bloom filter is aready being updated

    // the transaction likely consumed one or more wallet addresses, so check that at least the next <gap limit>
    // unused addresses are still matched by the bloom filter
    NSArray *external = [manager.wallet addressesWithGapLimit:SEQUENCE_GAP_LIMIT_EXTERNAL internal:NO],
            *internal = [manager.wallet addressesWithGapLimit:SEQUENCE_GAP_LIMIT_INTERNAL internal:YES];
    
    for (NSString *address in [external arrayByAddingObjectsFromArray:internal]) {
        NSData *hash = address.addressToHash160;

        if (! hash || [_bloomFilter containsData:hash]) continue;
        _bloomFilter = nil; // reset bloom filter so it's recreated with new wallet addresses
        [self updateFilter];
        break;
    }
}

- (void)peer:(BRPeer *)peer hasTransaction:(UInt256)txHash
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    NSValue *hash = uint256_obj(txHash);
    BOOL syncing = (self.lastBlockHeight < self.estimatedBlockHeight);
    BRTransaction *tx = self.publishedTx[hash];
    void (^callback)(NSError *error) = self.publishedCallback[hash];
    
    NSLog(@"%@:%d has transaction %@", peer.host, peer.port, hash);
    if (! tx) tx = [manager.wallet transactionForHash:txHash];
    if (! tx || (syncing && ! [manager.wallet containsTransaction:tx])) return;
    if (! [manager.wallet registerTransaction:tx]) return;
    if (peer == self.downloadPeer) self.lastRelayTime = [NSDate timeIntervalSinceReferenceDate];
    
    // keep track of how many peers have or relay a tx, this indicates how likely the tx is to confirm
    if (callback || (! syncing && ! [self.txRelays[hash] containsObject:peer])) {
        if (! self.txRelays[hash]) self.txRelays[hash] = [NSMutableSet set];
        [self.txRelays[hash] addObject:peer];
        if (callback) [self.publishedCallback removeObjectForKey:hash];

        if ([self.txRelays[hash] count] >= PEER_MAX_CONNECTIONS &&
            [manager.wallet transactionForHash:txHash].blockHeight == TX_UNCONFIRMED &&
            [manager.wallet transactionForHash:txHash].timestamp == 0) {
            [self setBlockHeight:TX_UNCONFIRMED andTimestamp:[NSDate timeIntervalSinceReferenceDate]
             forTxHashes:@[hash]]; // set timestamp when tx is verified
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            NSError *kvErr = nil;
            
            [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(txTimeout:) object:hash];
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
            if (callback) callback(nil);

            [[BRAPIClient sharedClient].kv
             set:[[BRTxMetadataObject alloc] initWithTransaction:tx exchangeRate:manager.localCurrencyPrice
                  exchangeRateCurrency:manager.localCurrencyCode feeRate:manager.wallet.feePerKb
                  deviceId:[BRAPIClient sharedClient].deviceId] error:&kvErr];
        });
    }
    
    [self.nonFpTx addObject:hash];
    [self.txRequests[hash] removeObject:peer];
}

- (void)peer:(BRPeer *)peer rejectedTransaction:(UInt256)txHash withCode:(uint8_t)code
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    BRTransaction *tx = [manager.wallet transactionForHash:txHash];
    NSValue *hash = uint256_obj(txHash);
    
    if ([self.txRelays[hash] containsObject:peer]) {
        [self.txRelays[hash] removeObject:peer];

        if (tx.blockHeight == TX_UNCONFIRMED) { // set timestamp 0 for unverified
            [self setBlockHeight:TX_UNCONFIRMED andTimestamp:0 forTxHashes:@[hash]];
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
#if DEBUG
            [[[UIAlertView alloc] initWithTitle:@"transaction rejected"
              message:[NSString stringWithFormat:@"rejected by %@:%d with code 0x%x", peer.host, peer.port, code]
              delegate:nil cancelButtonTitle:@"ok" otherButtonTitles:nil] show];
#endif
        });
    }
    
    [self.txRequests[hash] removeObject:peer];
    
    // if we get rejected for any reason other than double-spend, the peer is likely misconfigured
    if (code != REJECT_SPENT && [manager.wallet amountSentByTransaction:tx] > 0) {
        for (hash in tx.inputHashes) { // check that all inputs are confirmed before dropping peer
            UInt256 h = UINT256_ZERO;
            
            [hash getValue:&h];
            if ([manager.wallet transactionForHash:h].blockHeight == TX_UNCONFIRMED) return;
        }

        [self peerMisbehavin:peer];
    }
}

- (void)peer:(BRPeer *)peer relayedBlock:(BRMerkleBlock *)block
{
    // ignore block headers that are newer than one week before earliestKeyTime (headers have 0 totalTransactions)
    if (block.totalTransactions == 0 &&
        block.timestamp + 7*24*60*60 > self.earliestKeyTime + NSTimeIntervalSince1970 + 2*60*60) return;

    NSArray *txHashes = block.txHashes;

    // track the observed bloom filter false positive rate using a low pass filter to smooth out variance
    if (peer == self.downloadPeer && block.totalTransactions > 0) {
        NSMutableSet *fp = [NSMutableSet setWithArray:txHashes];
    
        // 1% low pass filter, also weights each block by total transactions, using 1400 tx per block as typical
        [fp minusSet:self.nonFpTx]; // wallet tx are not false-positives
        [self.nonFpTx removeAllObjects];
        self.fpRate = self.fpRate*(1.0 - 0.01*block.totalTransactions/1400) + 0.01*fp.count/1400;

        // false positive rate sanity check
        if (self.downloadPeer.status == BRPeerStatusConnected && self.fpRate > BLOOM_DEFAULT_FALSEPOSITIVE_RATE*10.0) {
            NSLog(@"%@:%d bloom filter false positive rate %f too high after %d blocks, disconnecting...", peer.host,
                  peer.port, self.fpRate, self.lastBlockHeight + 1 - self.filterUpdateHeight);
            [self.downloadPeer disconnect];
        }
        else if (self.lastBlockHeight + 500 < peer.lastblock && self.fpRate > BLOOM_REDUCED_FALSEPOSITIVE_RATE*10.0) {
            [self updateFilter]; // rebuild bloom filter when it starts to degrade
        }
    }

    if (! _bloomFilter) { // ingore potentially incomplete blocks when a filter update is pending
        if (peer == self.downloadPeer) self.lastRelayTime = [NSDate timeIntervalSinceReferenceDate];
        return;
    }

    NSValue *blockHash = uint256_obj(block.blockHash), *prevBlock = uint256_obj(block.prevBlock);
    BRMerkleBlock *prev = self.blocks[prevBlock];
    uint32_t transitionTime = 0, txTime = 0;
    UInt256 checkpoint = UINT256_ZERO;
    BOOL syncDone = NO;
    
    if (! prev) { // block is an orphan
        NSLog(@"%@:%d relayed orphan block %@, previous %@, last block is %@, height %d", peer.host, peer.port,
              blockHash, prevBlock, uint256_obj(self.lastBlock.blockHash), self.lastBlockHeight);

        // ignore orphans older than one week ago
        if (block.timestamp < [NSDate timeIntervalSinceReferenceDate] + NSTimeIntervalSince1970 - 7*24*60*60) return;

        // call getblocks, unless we already did with the previous block, or we're still downloading the chain
        if (self.lastBlockHeight >= peer.lastblock && ! uint256_eq(self.lastOrphan.blockHash, block.prevBlock)) {
            NSLog(@"%@:%d calling getblocks", peer.host, peer.port);
            [peer sendGetblocksMessageWithLocators:[self blockLocatorArray] andHashStop:UINT256_ZERO];
        }

        self.orphans[prevBlock] = block; // orphans are indexed by prevBlock instead of blockHash
        self.lastOrphan = block;
        return;
    }

    block.height = prev.height + 1;
    txTime = block.timestamp/2 + prev.timestamp/2;

    if ((block.height % nInterval) == 0) { // hit a difficulty transition, find previous transition time
        BRMerkleBlock *b = block;

        for (uint32_t i = 0; b && i < nInterval; i++) {
            b = self.blocks[uint256_obj(b.prevBlock)];
        }

        [[BRMerkleBlockEntity context] performBlock:^{ // save transition blocks to core data immediately
            @autoreleasepool {
                BRMerkleBlockEntity *e = [BRMerkleBlockEntity objectsMatching:@"blockHash == %@",
                                          [NSData dataWithBytes:b.blockHash.u8 length:sizeof(UInt256)]].lastObject;
        
                if (! e) e = [BRMerkleBlockEntity managedObject];
                [e setAttributesFromBlock:b];
            }
            
            [BRMerkleBlockEntity saveContext]; // persist core data to disk
        }];

        transitionTime = b.timestamp;
        
        while (b) { // free up some memory
            b = self.blocks[uint256_obj(b.prevBlock)];

            if (b && (b.height % nInterval) != 0) {
                [self.blocks removeObjectForKey:uint256_obj(b.blockHash)];
            }
        }
    }

    // verify block difficulty
    if (! [block verifyDifficultyFromPreviousBlock:prev andTransitionTime:transitionTime]) {
        NSLog(@"%@:%d relayed block with invalid difficulty target %x, blockHash: %@", peer.host, peer.port,
              block.target, blockHash);
        [self peerMisbehavin:peer];
        return;
    }

    [self.checkpoints[@(block.height)] getValue:&checkpoint];
    
    // verify block chain checkpoints
    if (! uint256_is_zero(checkpoint) && ! uint256_eq(block.blockHash, checkpoint)) {
        NSLog(@"%@:%d relayed a block that differs from the checkpoint at height %d, blockHash: %@, expected: %@",
              peer.host, peer.port, block.height, blockHash, self.checkpoints[@(block.height)]);
        [self peerMisbehavin:peer];
        return;
    }
    
    if (uint256_eq(block.prevBlock, self.lastBlock.blockHash)) { // new block extends main chain
        if ((block.height % 500) == 0 || txHashes.count > 0 || block.height > peer.lastblock) {
            NSLog(@"adding block at height: %d, false positive rate: %f", block.height, self.fpRate);
        }

        self.blocks[blockHash] = block;
        self.lastBlock = block;
        [self setBlockHeight:block.height andTimestamp:txTime - NSTimeIntervalSince1970 forTxHashes:txHashes];
        if (peer == self.downloadPeer) self.lastRelayTime = [NSDate timeIntervalSinceReferenceDate];
        self.downloadPeer.currentBlockHeight = block.height;
        if (block.height == _estimatedBlockHeight) syncDone = YES;
    }
    else if (self.blocks[blockHash] != nil) { // we already have the block (or at least the header)
        if ((block.height % 500) == 0 || txHashes.count > 0 || block.height > peer.lastblock) {
            NSLog(@"%@:%d relayed existing block at height %d", peer.host, peer.port, block.height);
        }

        self.blocks[blockHash] = block;

        BRMerkleBlock *b = self.lastBlock;

        while (b && b.height > block.height) b = self.blocks[uint256_obj(b.prevBlock)]; // is block in main chain?

        if (uint256_eq(b.blockHash, block.blockHash)) { // if it's not on a fork, set block heights for its transactions
            [self setBlockHeight:block.height andTimestamp:txTime - NSTimeIntervalSince1970 forTxHashes:txHashes];
            if (block.height == self.lastBlockHeight) self.lastBlock = block;
        }
    }
    else { // new block is on a fork
        if (block.height <= checkpoint_array[CHECKPOINT_COUNT - 1].height) { // fork is older than last checkpoint
            NSLog(@"ignoring block on fork older than most recent checkpoint, fork height: %d, blockHash: %@",
                  block.height, blockHash);
            return;
        }

        // special case, if a new block is mined while we're rescanning the chain, mark as orphan til we're caught up
        if (self.lastBlockHeight < peer.lastblock && block.height > self.lastBlockHeight + 1) {
            NSLog(@"marking new block at height %d as orphan until rescan completes", block.height);
            self.orphans[prevBlock] = block;
            self.lastOrphan = block;
            return;
        }

        NSLog(@"chain fork to height %d", block.height);
        self.blocks[blockHash] = block;
        if (block.height <= self.lastBlockHeight) return; // if fork is shorter than main chain, ignore it for now

        NSMutableArray *txHashes = [NSMutableArray array];
        BRMerkleBlock *b = block, *b2 = self.lastBlock;

        while (b && b2 && ! uint256_eq(b.blockHash, b2.blockHash)) { // walk back to where the fork joins the main chain
            b = self.blocks[uint256_obj(b.prevBlock)];
            if (b.height < b2.height) b2 = self.blocks[uint256_obj(b2.prevBlock)];
        }

        NSLog(@"reorganizing chain from height %d, new height is %d", b.height, block.height);

        // mark transactions after the join point as unconfirmed
        for (BRTransaction *tx in [BRWalletManager sharedInstance].wallet.allTransactions) {
            if (tx.blockHeight <= b.height) break;
            [txHashes addObject:uint256_obj(tx.txHash)];
        }

        [self setBlockHeight:TX_UNCONFIRMED andTimestamp:0 forTxHashes:txHashes];
        b = block;

        while (b.height > b2.height) { // set transaction heights for new main chain
            [self setBlockHeight:b.height andTimestamp:txTime - NSTimeIntervalSince1970 forTxHashes:b.txHashes];
            b = self.blocks[uint256_obj(b.prevBlock)];
            txTime = b.timestamp/2 + ((BRMerkleBlock *)self.blocks[uint256_obj(b.prevBlock)]).timestamp/2;
        }

        self.lastBlock = block;
        if (block.height == _estimatedBlockHeight) syncDone = YES;
    }

    if (syncDone) { // chain download is complete
        self.syncStartHeight = 0;
        [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:SYNC_STARTHEIGHT_KEY];
        [self saveBlocks];
        [self loadMempools];
    }
    
    if (block.height > _estimatedBlockHeight) {
        _estimatedBlockHeight = block.height;
    
        // notify that transaction confirmations may have changed
        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
        });
    }
    
    // check if the next block was received as an orphan
    if (block == self.lastBlock && self.orphans[blockHash]) {
        BRMerkleBlock *b = self.orphans[blockHash];
        
        [self.orphans removeObjectForKey:blockHash];
        [self peer:peer relayedBlock:b];
    }
}

- (void)peer:(BRPeer *)peer notfoundTxHashes:(NSArray *)txHashes andBlockHashes:(NSArray *)blockhashes
{
    for (NSValue *hash in txHashes) {
        [self.txRelays[hash] removeObject:peer];
        [self.txRequests[hash] removeObject:peer];
    }
}

- (void)peer:(BRPeer *)peer setFeePerKb:(uint64_t)feePerKb
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    uint64_t maxFeePerKb = 0, secondFeePerKb = 0;
    
    for (BRPeer *p in self.connectedPeers) { // find second highest fee rate
        if (p.status != BRPeerStatusConnected) continue;
        if (p.feePerKb > maxFeePerKb) secondFeePerKb = maxFeePerKb, maxFeePerKb = p.feePerKb;
    }
    
    if (secondFeePerKb*2 > MIN_FEE_PER_KB && secondFeePerKb*2 <= MAX_FEE_PER_KB &&
        secondFeePerKb*2 > manager.wallet.feePerKb) {
        NSLog(@"increasing feePerKb to %llu based on feefilter messages from peers", secondFeePerKb*2);
        manager.wallet.feePerKb = secondFeePerKb*2;
    }
}

- (BRTransaction *)peer:(BRPeer *)peer requestedTransaction:(UInt256)txHash
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    NSValue *hash = uint256_obj(txHash);
    BRTransaction *tx = self.publishedTx[hash];
    void (^callback)(NSError *error) = self.publishedCallback[hash];
    NSError *error = nil;

    if (! self.txRelays[hash]) self.txRelays[hash] = [NSMutableSet set];
    [self.txRelays[hash] addObject:peer];
    [self.nonFpTx addObject:hash];
    [self.publishedCallback removeObjectForKey:hash];
    
    if (callback && ! [manager.wallet transactionIsValid:tx]) {
        [self.publishedTx removeObjectForKey:hash];
        error = [NSError errorWithDomain:@"BreadWallet" code:401
                 userInfo:@{NSLocalizedDescriptionKey:NSLocalizedString(@"double spend", nil)}];
    }
    else if (tx && ! [manager.wallet transactionForHash:txHash] && [manager.wallet registerTransaction:tx]) {
        [[BRTransactionEntity context] performBlock:^{
            [BRTransactionEntity saveContext]; // persist transactions to core data
        }];
    }
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(txTimeout:) object:hash];
        if (callback) callback(error);
    });

//    [peer sendPingMessageWithPongHandler:^(BOOL success) { // check if peer will relay the transaction back
//        if (! success) return;
//        
//        if (! [self.txRequests[hash] containsObject:peer]) {
//            if (! self.txRequests[hash]) self.txRequests[hash] = [NSMutableSet set];
//            [self.txRequests[hash] addObject:peer];
//            [peer sendGetdataMessageWithTxHashes:@[hash] andBlockHashes:nil];
//        }
//    }];

    return tx;
}

// MARK: - UIAlertViewDelegate

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    if (buttonIndex == alertView.cancelButtonIndex) return;
    [self rescan];
}

@end
